{
  "id": "validations-and-assertions",
  "name": "Validations and Assertions",
  "index": 19,
  "lesson": 19,
  "summary": "Introduction to validations and assertions and how to use it in your smart contracts.",
  "labels": [
    "solidity"
  ],
  "content": {
    "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Validations and Assertions\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Validations and assertions are used to check the correctness of the data in your smart contract. They are used to ensure that the data is as expected and to prevent the contract from executing if the data is not as expected.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Validations and assertions also throws an error by calling \", _jsx(_components.code, {\n        children: \"require\"\n      }), \", \", _jsx(_components.code, {\n        children: \"revert\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"assert\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"require(bool condition)\"\n          }), \": abort execution and revert state changes if condition is false (use as error in external component)\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"require(bool condition, string memory message)\"\n          }), \": abort execution and revert state changes if condition is false. Also provide error message.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"revert()\"\n          }), \": abort execution and revert state changes\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"revert(string memory message)\"\n          }), \": abort execution and revert state changes providing an explanatory string\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"assert(bool condition)\"\n          }), \": abort execution and revert state changes if condition is false (use for internal error)\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ncontract MyContract {\\n    mapping(address => uint) public balance;\\n\\n    function deposit(uint amount) public {\\n        // Use require to validate inputs from external calls\\n        require(amount > 0, \\\"Deposit amount must be greater than 0\\\");\\n\\n        balance[msg.sender] += amount;\\n    }\\n\\n    function withdraw(uint amount) public {\\n        // Use require to validate inputs from external calls\\n        require(amount <= balance[msg.sender], \\\"Insufficient balance\\\");\\n\\n        balance[msg.sender] -= amount;\\n    }\\n\\n    function transfer(address to, uint amount) public {\\n        // Use revert to abort execution and revert state changes\\n        if (to == address(0)) {\\n            revert(\\\"Cannot transfer to zero address\\\");\\n        }\\n\\n        // Use require to validate inputs from external calls\\n        require(amount <= balance[msg.sender], \\\"Insufficient balance\\\");\\n\\n        balance[msg.sender] -= amount;\\n        balance[to] += amount;\\n\\n        // Use assert for internal errors that should never happen\\n        assert(balance[msg.sender] + balance[to] == amount);\\n    }\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",
    "frontmatter": {},
    "scope": {}
  }
}