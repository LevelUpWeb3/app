{
  "id": "events",
  "name": "Events",
  "index": 21,
  "lesson": 21,
  "summary": "Introduction to events and how to use it in your smart contracts.",
  "labels": [
    "solidity"
  ],
  "content": {
    "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Events\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Events are emitted by the EVM when certain actions are performed. They are defined in the contract code using the \", _jsx(_components.code, {\n        children: \"event\"\n      }), \" keyword and can be emitted using the \", _jsx(_components.code, {\n        children: \"emit\"\n      }), \" keyword.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can add the attribute \", _jsx(_components.code, {\n        children: \"indexed\"\n      }), \" to up to three parameters. These parameters are added to special data structure known as \\\"Topics\\\".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Topics allow you to search for events. Parameters without the \", _jsx(_components.code, {\n        children: \"indexed\"\n      }), \" attribute are stored in the data section of the log.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"pragma solidity ^0.8.0;\\n\\ncontract MyContract {\\n    // Define events\\n    event Transaction(address indexed sender, address indexed receiver, uint256 amount);\\n    event UserRegistered(address indexed user, string name);\\n    event UserUpdated(address indexed user, string name);\\n    event ContractPaused();\\n    event ContractResumed();\\n\\n    // Struct to hold user data\\n    struct User {\\n        string name;\\n    }\\n\\n    // Mapping from address to User data\\n    mapping(address => User) public users;\\n\\n    // Variable to track whether the contract is paused\\n    bool public paused = false;\\n\\n    // Function to transfer funds\\n    function transferFunds(address receiver, uint256 amount) public {\\n        (bool success, ) = receiver.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Transfer failed.\\\");\\n\\n        // Emit the event to log the transaction\\n        emit Transaction(msg.sender, receiver, amount);\\n    }\\n\\n    // Function to register a new user\\n    function registerUser(string memory name) public {\\n        users[msg.sender] = User(name);\\n        emit UserRegistered(msg.sender, name);\\n    }\\n\\n    // Function to update a user's information\\n    function updateUser(string memory name) public {\\n        users[msg.sender].name = name;\\n        emit UserUpdated(msg.sender, name);\\n    }\\n\\n    // Function to pause the contract\\n    function pauseContract() public {\\n        paused = true;\\n        emit ContractPaused();\\n    }\\n\\n    // Function to resume the contract\\n    function resumeContract() public {\\n        paused = false;\\n        emit ContractResumed();\\n    }\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",
    "frontmatter": {},
    "scope": {}
  }
}