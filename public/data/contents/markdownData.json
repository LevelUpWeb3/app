[
  {
    "id": "exploring-solidity-objects-address-part-1",
    "name": "Exploring Solidity Objects: Address - Part 1",
    "index": 1,
    "summary": "Dive into the world of Solidity in pursuit of leveling up! Starting with Address object.",
    "author": "RH",
    "authorIcon": "https://pbs.twimg.com/profile_images/1751242830398287872/8VKShh46.jpg",
    "authorLink": "https://x.com/rh_bdl",
    "published": "Jul 03, 2024",
    "readTime": "3 min read",
    "labels": [
      "Smart Contract"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    h3: \"h3\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"If you have been tinkering with Solidity, you might have used or came across the \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" object in Solidity. Common use cases of this object includes reading \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" balance, and sending tokens.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this article, we will explore the different members of \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" while referencing Solidity's \", _jsx(_components.a, {\n        href: \"https://docs.soliditylang.org/en/latest/cheatsheet.html#members-of-address\",\n        children: \"docs\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"1. Balance\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The balance member provides access to read balance of address in Wei (1 Ether = 10^18 Wei).\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"function retrieveBalance() public view returns (uint256) {\\n    //returns ETH balance of deployed contract in Wei\\n    return address(this).balance;\\n}\\n\\nfunction retrieveUserBalance(address user) public view returns (uint256) {\\n    //returns ETH balance of user's address in Wei\\n    return address(user).balance;\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"retrieveBalance()\"\n      }), \" function is an example of a gotcha that catches new Solidity devs off-guard. It is not unusual to assume that \", _jsx(_components.code, {\n        children: \"address(this).balance\"\n      }), \" would return the balance of our address. In reality, it is the balance of the smart contract itself that is read.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"2. Code\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"code\"\n      }), \" member allows us to query the deployed contract’s bytecode information.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"function retrieveCode() public view returns (bytes memory) {\\n    //returns EVM bytecode\\n    return address(this).code;\\n}\\n\\nfunction retrieveCodehash() public view returns (bytes32) {\\n    //returns Keccak-256 hash of the EVM bytecode\\n    return address(this).codehash;\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"retrieveCode()\"\n      }), \" queries the EVM bytecode and in this example, the output looks something like this “0x60806040…4300081a0033”.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is useful for contract verification purposes. \", _jsx(_components.a, {\n        href: \"https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\",\n        children: \"Here\"\n      }), \" is an example of WETH’s deployed contract in Etherscan. Scroll below to see the Deployed Bytecode’s output.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"retrieveCodehash()\"\n      }), \" simply provides the Keccak-256 hash of the output. It provides a more efficient way to verify the deployed contract as it is cheaper in terms of gas costs.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"3. Transfer, Send & Call\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"• Transfer & Send\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Typically invoked for sending Ether. Level Up has also put together a \", _jsx(_components.a, {\n        href: \"(https://www.levelupweb3.xyz/solidity/transacting-ether)\",\n        children: \"guide\"\n      }), \" covering these members. The section below covers the output/responses when using these members.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"function transferKeyword(uint256 ethAmount) public {\\n    // NOT recommended for sending Ether\\n    // Reverts with error if txn fails\\n    payable(address(this)).transfer(ethAmount);\\n}\\n\\nfunction sendKeyword(uint256 ethAmount) public returns (bool) {\\n    // NOT recommended for sending Ether\\n    // Reverts with bool: \\\"false\\\" if txn fails\\n    return payable(address(this)).send(ethAmount);\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"transfer\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"send\"\n      }), \" members are \", _jsx(_components.em, {\n        children: \"not\"\n      }), \" recommended for sending Ether. Take note on the expected responses if you plan to use them.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In situations of failed transactions, \", _jsx(_components.code, {\n        children: \"transfer\"\n      }), \" reverts with an error while \", _jsx(_components.code, {\n        children: \"send\"\n      }), \" returns a boolean value of \", _jsx(_components.code, {\n        children: \"false\"\n      }), \" (but the transaction will be successful).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.strong, {\n        children: [\"Note: \", _jsx(_components.code, {\n          children: \"send\"\n        }), \" updates state, but \", _jsx(_components.code, {\n          children: \"transfer\"\n        }), \" does not. Both members still consume gas regardless of the transaction status.\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"• Call\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"function callKeyword(uint256 ethAmount) public {\\n    // RECOMMENDED method to send Ether\\n    // Passing blanks (\\\"\\\") because the example below shows empty calldata\\n    (bool sent, ) = address(this).call{value: ethAmount}(\\\"\\\");\\n    require(sent, \\\"Failed to send Ether\\\");\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"call\"\n      }), \" is recommended due to its \", _jsx(_components.a, {\n        href: \"https://forum.openzeppelin.com/t/should-we-never-use-the-transfer-function/38445\",\n        children: \"flexibility for sending Ether\"\n      }), \". It also allows you to pass arguments if interacting with custom functions that require any parameters.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This concludes part 1. In the next part, we will cover other members of the address object such as \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \". Stay tuned!\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "exploring-solidity-objects-address-part-2",
    "name": "Exploring Solidity Objects: Address - Part 2",
    "index": 2,
    "summary": "Dive into the world of Solidity in pursuit of leveling up! Venturing into delegatecall and staticcall functions!",
    "author": "RH",
    "authorIcon": "https://pbs.twimg.com/profile_images/1751242830398287872/8VKShh46.jpg",
    "authorLink": "https://x.com/rh_bdl",
    "published": "Aug 06, 2024",
    "readTime": "6 min read",
    "labels": [
      "Smart Contract"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    strong: \"strong\",\n    h2: \"h2\",\n    pre: \"pre\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {YoutubeEmbed} = _components;\n  if (!YoutubeEmbed) _missingMdxReference(\"YoutubeEmbed\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In \", _jsx(_components.a, {\n        href: \"https://rhbdl.substack.com/p/exploring-solidity-objects-address?r=1v972g\",\n        children: \"Part 1\"\n      }), \", we explored different \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" members and their use cases. While the previous article explored scenarios involving sending Ether, it is helpful to know that the functionalities extend beyond that.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For instance, the \", _jsx(_components.code, {\n        children: \"call\"\n      }), \" function is a low-level function which has the capability to invoke any function on any target contract by specifying the function signature and arguments in the \\\"data\\\" parameter. \", _jsx(_components.strong, {\n        children: \"(Security Note: call never reverts. It is our responsibility to handle unsuccessful transaction errors.)\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, let's delve into the final two members of the address object: \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \". These members are also interchangeably referred as functions - particularly when describing their role in code execution through invocation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The underlying concept of \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \" is relatively straightforward, as they are essentially specialized variants of the \", _jsx(_components.code, {\n        children: \"call\"\n      }), \" function.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"1. delegatecall\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This function allows state modifying instructions while preserving the original contract's context (storage, sender address, and value).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"At this point, you might be wondering about the terminology “delegatecall”. How exactly are the function calls “delegated”? Or rather, what is the mode of “delegation” here?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's utilise the code below to answer these questions!\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"pragma solidity ^0.8.24;\\n\\ncontract Caller {\\nuint256 public value;\\n\\n    function setVars(uint256 _value) public payable {\\n        value = _value;\\n    }\\n\\n}\\n\\ncontract DelegateCaller {\\nuint256 public value;\\n\\n    function setVars(address _callerContract, uint256 _value) public payable {\\n        // Caller delegated its setVars() function to DelegateCaller Contract\\n        (bool success, ) = _callerContract.delegatecall(\\n            abi.encodeWithSignature(\\\"setVars(uint256)\\\", _value)\\n        );\\n        if (!success) revert(\\\"Failed\\\");\\n    }\\n\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When \", _jsx(_components.code, {\n        children: \"setVars()\"\n      }), \" is called in DelegateCaller contract, the \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \" invokes the \", _jsx(_components.code, {\n        children: \"setVars()\"\n      }), \" function in the Caller contract but in the DelegateCaller execution environment.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Thus, Caller contract has effectively delegated its function to DelegateCaller contract.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's explore further using the video below! (\", _jsxs(_components.strong, {\n        children: [\"Watch what happens when \", _jsx(_components.code, {\n          children: \"setVars()\"\n        }), \" was called in DelegateCaller contract.\"]\n      }), \" Observe how the \", _jsx(_components.code, {\n        children: \"value\"\n      }), \" variables change in the context of Caller and DelegateCaller contract.)\"]\n    }), \"\\n\", _jsx(YoutubeEmbed, {\n      id: \"IUhr8N_WroI\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.em, {\n        children: [\"Were you able to identify the contract that had its \", _jsx(_components.code, {\n          children: \"value\"\n        }), \" variable updated when \", _jsx(_components.code, {\n          children: \"delegatecall\"\n        }), \" was invoked?\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This behavior might seem redundant at first when we can simply use \", _jsx(_components.code, {\n        children: \"call\"\n      }), \" function. However, \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \" enables use cases such as for proxy contracts - where only the implementation contract (i.e. Uniswap V2, V3) is upgraded to preserve the context of the proxy contract.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Having explored the complexities of \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \", let’s proceed to explore \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" which is relatively simpler!\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"2. staticcall\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In general, \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" does not allow any state modifying instructions or capability to send ether. It will revert if there are any state changes during the function invocation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"At a low-level, it disallows opcodes such as CREATE, SSTORE, SELFDESTRUCT, and few \", _jsx(_components.a, {\n        href: \"https://www.evm.codes/#fa?fork=cancun\",\n        children: \"others\"\n      }), \". Personally, I view \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" as a safer variant of the call function to read state.\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"/images/contents/staticcall.png\",\n        alt: \"staticcall example\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsxs(_components.em, {\n          children: [\"Figure 1: \", _jsx(_components.code, {\n            children: \"staticcall\"\n          }), \" example\"]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the example above, notice how the \", _jsx(_components.code, {\n        children: \"value\"\n      }), \" variable for StaticCaller contract did not change. It remains as “0” even when Caller contract has been updated to store “100” in its \", _jsx(_components.code, {\n        children: \"value\"\n      }), \" variable. Unlike \", _jsx(_components.code, {\n        children: \"delegatecall\"\n      }), \" which allows state modifying instruction, \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" only reads state of the target contract (Caller contract in this example).\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As a treat, I have also included a function \", _jsx(_components.code, {\n        children: \"setVars()\"\n      }), \" which purposefully calls a state modifying function from the target contract to simulate transaction failure. Watch the video towards the end to learn what happens when \", _jsx(_components.code, {\n        children: \"success\"\n      }), \" returns false.\"]\n    }), \"\\n\", _jsx(YoutubeEmbed, {\n      id: \"iGQ5z6B1PQw\"\n    }), \"\\n\", _jsx(\"div\", {\n      className: \"text-center\",\n      children: _jsx(_components.p, {\n        children: _jsxs(_components.em, {\n          children: [\"Explore this code further here:\\n\", _jsx(_components.a, {\n            href: \"https://remix.ethereum.org/?#code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVApwcmFnbWEgc29saWRpdHkgXjAuOC4yNDsKCmNvbnRyYWN0IENhbGxlciB7CiAgICB1aW50MjU2IHB1YmxpYyB2YWx1ZTsKCiAgICBmdW5jdGlvbiBzZXRWYXJzKHVpbnQyNTYgX3ZhbHVlKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgdmFsdWUgPSBfdmFsdWU7CiAgICB9CgogICAgZnVuY3Rpb24gcmVhZFZhbHVlKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiB2YWx1ZTsKICAgIH0KfQoKY29udHJhY3QgU3RhdGljQ2FsbGVyIHsKICAgIHVpbnQyNTYgcHVibGljIHZhbHVlOwoKICAgIGZ1bmN0aW9uIHNldFZhcnMoYWRkcmVzcyBfY2FsbGVyQ29udHJhY3QsIHVpbnQyNTYgX3ZhbHVlKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgKGJvb2wgc3VjY2VzcywgKSA9IF9jYWxsZXJDb250cmFjdC5zdGF0aWNjYWxsKAogICAgICAgICAgICBhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgic2V0VmFycyh1aW50MjU2KSIsIF92YWx1ZSkKICAgICAgICApOwogICAgICAgIGlmKCFzdWNjZXNzKSByZXZlcnQgKCJFcnJvciBpbiBzdGF0aWNjYWxsIik7CiAgICB9CgogICAgZnVuY3Rpb24gcmVhZFZhcnMoYWRkcmVzcyBfY2FsbGVyQ29udHJhY3QpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICAoLCBieXRlcyBtZW1vcnkgZGF0YSkgPSBfY2FsbGVyQ29udHJhY3Quc3RhdGljY2FsbChhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVhZFZhbHVlKCkiKSk7CiAgICAgICAgcmV0dXJuIGFiaS5kZWNvZGUoZGF0YSwgKHVpbnQyNTYpKTsKICAgIH0KfQ&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.26+commit.8a97fa7a.js\",\n            children: \"staticcall.sol\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In \", _jsx(_components.a, {\n        href: \"https://ethglobal.com/events/brussels/prizes/scroll\",\n        children: \"ETH CC Brussels\"\n      }), \", Scroll introduced the experimental \", _jsx(_components.a, {\n        href: \"https://ethereum-magicians.org/t/rip-7728-l1sload-precompile/20388\",\n        children: \"L1SLOAD precompile\"\n      }), \" which uses \", _jsx(_components.code, {\n        children: \"staticcall\"\n      }), \" under the hood.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Hackers were able to explore novel methods of resolving ENS address, extending NFT ownership - all on L2. Despite preliminary stage of experimentation, this highlights that the potential opportunities for this function are virtually limitless.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now that you have equipped yourself with an arsenal of knowledge on the \", _jsx(_components.code, {\n        children: \"address\"\n      }), \" object, you are now capable of address-ing (Hehe! Pun intended) more intermediate to advanced level builds. Can't wait to hear all about how you will be using this knowledge to level up your projects.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "level-up-foundry",
    "name": "Level Up: Building with Foundry",
    "index": 3,
    "summary": "Learn smart contract development with Foundry, a blazingly fast framework for building and deploying smart contracts!",
    "author": "RH",
    "authorIcon": "https://pbs.twimg.com/profile_images/1751242830398287872/8VKShh46.jpg",
    "authorLink": "https://x.com/rh_bdl",
    "published": "Sep 09, 2024",
    "readTime": "11 min read",
    "labels": [
      "Smart Contract"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    strong: \"strong\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    h3: \"h3\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"In Level Up, this Foundry module is designed to reduce friction by immediately equipping you with fundamental skills to develop smart contracts on Scroll Sepolia.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In order to facilitate this process, we have curated a simplified structure to help you get started with Foundry on Scroll Sepolia.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you are feeling adventurous, jump into your code editor and follow along!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Introduction\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"What is Foundry?\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://book.getfoundry.sh/\",\n        children: \"Foundry\"\n      }), \" is a blazingly fast, portable and modular toolkit for Ethereum application development written in Rust.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Why Foundry?\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Write all your code ONLY in Solidity (i.e. scripts, tests, all in Solidity)!\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Speedrun your developer journey without having to learn multiple languages.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"How Foundry?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Glad you asked 🔥.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's dive right in!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"[0]: Install Foundry\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Foundry is installed using Foundryup.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"curl -L https://foundry.paradigm.xyz | bash\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Source your \", _jsx(_components.code, {\n        children: \".zshenv\"\n      }), \" file to ensure the path is updated.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"source /Users/your_username/.zshenv\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To verify the installation, run the following command:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"forge --version\\n// forge 0.x.x ...\\ncast --version\\n// cast 0.x.x ...\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Additional resource from Foundry Book specific to \", _jsx(_components.a, {\n        href: \"https://book.getfoundry.sh/getting-started/installation\",\n        children: \"installation\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"[1]: Create a Foundry Project\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Create a new project and navigate into it.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"mkdir foundry-project\\ncd foundry-project\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Run \", _jsx(_components.code, {\n        children: \"forge init\"\n      }), \" in your terminal to create a new Foundry project.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"$foundry-project forge init\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"[2]: Compiling a Foundry Project\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this example, we will use a simple EtherWallet example below:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ncontract EtherWallet {\\naddress payable public owner;\\n\\n    constructor() {\\n        owner = payable(msg.sender);\\n    }\\n\\n    receive() external payable {}\\n\\n    function withdraw(uint _amount) external {\\n        require(msg.sender == owner, \\\"caller is not owner\\\");\\n        payable(msg.sender).transfer(_amount);\\n    }\\n\\n    function getBalance() external view returns (uint) {\\n        return address(this).balance;\\n    }\\n\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Rename \", _jsx(_components.code, {\n        children: \"Contract.sol\"\n      }), \" in \", _jsx(_components.code, {\n        children: \"src/Contract.sol\"\n      }), \" to \", _jsx(_components.code, {\n        children: \"EtherWallet.sol\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Delete \", _jsx(_components.code, {\n        children: \"src/test\"\n      }), \" folder. We will not be using it in this Speedrun lesson.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Run \", _jsx(_components.code, {\n        children: \"forge build\"\n      }), \" to compile the contract:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"$foundry-project forge build\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Navigate to the \", _jsx(_components.code, {\n        children: \"out\"\n      }), \" folder and you will see the compiled contract \", _jsx(_components.code, {\n        children: \"EtherWallet.json\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"[3]: Deploying on anvil\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Anvil is a local testnet node shipped with Foundry.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Run \", _jsx(_components.code, {\n        children: \"anvil\"\n      }), \" in your terminal.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"$foundry-project anvil\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This command spins up a local server hosted on \", _jsx(_components.a, {\n        href: \"http://localhost:8545\",\n        children: \"http://localhost:8545\"\n      }), \" that runs the test network. (Server URL can vary depending on user environment)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To deploy on anvil, run:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"// $foundry-project forge create <NAME CONTRACT> --rpc-url <LOCALHOST> --interactive\\nforge create EtherWallet --rpc-url http://localhost:8545 --interactive\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You will be prompted to enter your private key. Go into the anvil terminal, then copy any private key from the terminal.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Paste it in the terminal where you are deploying the contract.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"// $foundry-project forge create <NAME CONTRACT> --rpc-url <LOCALHOST> --interactive\\nforge create EtherWallet --rpc-url http://localhost:8545 --interactive\\n// paste anvil private key\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"After running the command, you should see an output similar to this:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"Deployer: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\\nDeployed to: 0x5FbDB2315678afecb367f032d93F642f64180aa3\\nTransaction hash: 0x4b1d82d3d33674496088b5e92e99494280ffcc1f27035269873a5ca04c432c93\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"[4]: Deploying with Script\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Foundry allows you to deploy smart contracts by running a script. Scripts are recognisable through the \", _jsx(_components.code, {\n        children: \"s.sol\"\n      }), \" extension and stored in \", _jsx(_components.code, {\n        children: \"/scripts\"\n      }), \" folder.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is what a script example named \", _jsx(_components.code, {\n        children: \"DeployEtherWallet.s.sol\"\n      }), \" would look like:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport { Script, console2 } from \\\"forge-std/Script.sol\\\";\\nimport { EtherWallet } from \\\"../src/EtherWallet.sol\\\";\\n\\ncontract EtherWalletScript is Script {\\nfunction run() external returns (EtherWallet) {\\nvm.startBroadcast();\\n\\n       EtherWallet etherWallet = new EtherWallet();\\n\\n       vm.stopBroadcast();\\n       return etherWallet;\\n\\n}\\n}\\n\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Use \", _jsx(_components.code, {\n        children: \"anvil\"\n      }), \" to simulate onchain transactions.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"$foundry-project forge script script/DeployEtherWallet.s.sol --rpc-url http://localhost:8545 --broadcast\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Forge simulates the script and \", _jsx(_components.code, {\n        children: \"—broadcast\"\n      }), \" flag was added to broadcast the transaction.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"[5]: Setting up Deployment Environment\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are two ways to do this in Foundry. One is the traditional way of using a \", _jsx(_components.code, {\n        children: \".env\"\n      }), \" file and the other is by using Foundry tools. Patrick Collins did an amazing job explaining it \", _jsx(_components.a, {\n        href: \"https://www.youtube.com/watch?v=VQe7cIpaE54\",\n        children: \"here\"\n      }), \"!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We'll start off with explaining the awesome way using Foundry!\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Using Foundry Tools\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Open your local machine terminal and run:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"// cast wallet import <ACCOUNT_NAME> --interactive\\ncast wallet import defaultKey --interactive\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You will be prompted to enter your private key and a password to secure \", _jsx(_components.code, {\n        children: \"<ACCOUNT_NAME>\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"REMINDER: We recommend to pass your private key and a password on your computer's terminal and NOT the code editor.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For additional security measures:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Leveled up security - Delete your history by running the following command:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"history -c\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Godlike security - Run \", _jsx(_components.code, {\n        children: \"rm <TERMINAL_HISTORY>\"\n      }), \" to delete your terminal history!\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"rm .bash_history\\n// or rm .zsh_history if you use zsh shell\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Finally, run the command below to see the list of all accounts available:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"cast wallet list\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"Using \", _jsx(_components.code, {\n        children: \".env\"\n      }), \" File\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Create a \", _jsx(_components.code, {\n        children: \".env\"\n      }), \" file in the root directory of your project.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"$foundry-project touch .env\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"File contents would look like this:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"PRIVATE_KEY=0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\\nRPC_URL=http://localhost:8545\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Load \", _jsx(_components.code, {\n        children: \".env\"\n      }), \" file in foundry by running:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"$foundry-project source .env\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To deploy a contract, you can now run:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"$foundry-project forge script script/DeployEtherWallet.s.sol --rpc-url $RPC_URL --broadcast --private-key $PRIVATE_KEY\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"REMINDER: You should \", _jsx(_components.strong, {\n        children: \"NEVER\"\n      }), \" place a private key or a secret phrase in a \", _jsx(_components.code, {\n        children: \".env\"\n      }), \" file that is associated with real funds! This is a HUGE security risk. (If you have not taken the .env pledge, do it \", _jsx(_components.a, {\n        href: \"https://github.com/smartcontractkit/full-blockchain-solidity-course-js/discussions/5\",\n        children: \"NOW\"\n      }), \"!)\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"[6]: Deploy on Scroll Sepolia Network\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Setting up Scroll Sepolia Network & Testnet Funds\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We're almost there to deployment!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First let's add the Scroll network to your metamask.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Head over to \", _jsx(_components.a, {\n        href: \"https://sepolia.scroll.io/portal\",\n        children: \"Scroll Sepolia\"\n      }), \" and add Scroll Sepolia testnet to your wallet.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note: Check out this quick \", _jsx(_components.a, {\n        href: \"https://twitter.com/BuildWithScroll/status/1714789104129581454\",\n        children: \"video on X\"\n      }), \" if you prefer adding Scroll Sepolia via \", _jsx(_components.a, {\n        href: \"https://chainlist.org/chain/534351\",\n        children: \"Chainlist\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now that we've added the network to our MetaMask, \", _jsx(_components.a, {\n        href: \"https://t.me/+PdNbk5milo1mMTAy\",\n        children: \"click here\"\n      }), \" to join Level Up Telegram group for Scroll Sepolia ETH or visit the faucet links in \", _jsx(_components.a, {\n        href: \"https://docs.scroll.io/en/user-guide/faucet/\",\n        children: \"Scroll's Faucet documentation\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you run into issues with testnet eth, please let us know in the Level Up Telegram group.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Deploying to Scroll Sepolia\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Contract deployment uses \", _jsx(_components.code, {\n        children: \"forge create\"\n      }), \" command.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"$foundry-project forge create <CONTRACT_NAME> --rpc-url <NETWORK> --account <ACCOUNT_NAME>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this case, the command will look like this:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"$foundry-project forge create EtherWallet --rpc-url https://sepolia-rpc.scroll.io/ --account defaultKey --broadcast\\n// optional: add -vvv for verbose output (add v's as needed to increase verbosity)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Enter your password and voila! Your contract is deployed on Scroll Sepolia!\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you are updating the \", _jsx(_components.code, {\n        children: \"RPC_URL\"\n      }), \" in \", _jsx(_components.code, {\n        children: \".env\"\n      }), \", remember to run \", _jsx(_components.code, {\n        children: \"source .env\"\n      }), \" to reload the environment variable changes.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"[7]: Contract Verification\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Verifying your contract makes your contract readable on a block explorer like Etherscan or \", _jsx(_components.strong, {\n        children: _jsx(_components.a, {\n          href: \"https://sepolia.scrollscan.com/\",\n          children: \"Scrollscan\"\n        })\n      }), \". This also provides a user interface for contract interaction.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You will first need API keys to verify your contract via Foundry. Here's how to do this:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Create an account at \", _jsx(_components.a, {\n          href: \"https://scrollscan.com/register\",\n          children: \"https://scrollscan.com/register\"\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Get API Keys from your account\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here's an explainer \", _jsx(_components.a, {\n        href: \"https://youtu.be/ks9Cj-lP1Tw?t=360\",\n        children: \"video\"\n      }), \" if you are stuck.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Update your \", _jsx(_components.code, {\n        children: \".env\"\n      }), \" file to include two new variables:\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"VERIFIER_URL\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"SCROLLSCAN_API_KEY\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Reload the environment variables by running \", _jsx(_components.code, {\n        children: \"source .env\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The command structure for verifying contract is as follows:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"forge verify-contract <CONTRACT_ADDRESS> <CONTRACT_NAME>\\n  --verifier-url <BLOCK_EXPLORER_URL> \\\\\\n  --etherscan-api-key <SCROLLSCAN_API_KEY> \\\\\\n  --constructor-args <CONSTRUCTOR_ARGUMENTS> //if any\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is an example of my command with a random contract address:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"forge verify-contract 0x998608B4f83249c4217ADb9060Fb739d4A52C6A2 EtherWallet\\n  --verifier-url $VERIFIER_URL \\\\\\n  --etherscan-api-key $SCROLLSCAN_API_KEY \\\\\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"[8]: Contract Interaction\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can interact with your smart contract by using the \", _jsx(_components.code, {\n        children: \"cast\"\n      }), \" command.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here is the general structure to using \", _jsx(_components.code, {\n        children: \"cast\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"cast [options] <CONTRACT_FUNCTION> [args]\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While there are many \", _jsx(_components.a, {\n        href: \"https://book.getfoundry.sh/reference/cast/cast?highlight=cast#cast\",\n        children: \"options\"\n      }), \" available to interact with contracts, we focus on the two common options: \", _jsx(_components.code, {\n        children: \"call\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"send\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.code, {\n        children: \"call\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To retrieve data from the contract in the blockchain:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"// Get the balance of the contract\\n$foundry-project cast call 0x998608B4f83249c4217ADb9060Fb739d4A52C6A2 \\\"getBalance()\\\" --rpc-url $RPC_URL\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"NOTE: Private key does not need to be passed in \", _jsx(_components.code, {\n        children: \"call\"\n      }), \" command as it does not require any transaction to be sent.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.code, {\n        children: \"send\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To execute function in the contract:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"// Send 0.1 Ether to the contract\\n$foundry-project cast send 0x998608B4f83249c4217ADb9060Fb739d4A52C6A2 --value 100000000000000000 --private-key $PRIVATE_KEY --rpc-url $RPC_URL\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"// Withdraw 0.000099999999999999 Ether\\n$foundry-project cast send 0x998608B4f83249c4217ADb9060Fb739d4A52C6A2 \\\"withdraw(uint)\\\" 99999999999999990 --private-key $PRIVATE_KEY --rpc-url $RPC_URL\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Foundry summary\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Congratulations! You made it to the end of speedrunning Foundry Smart Contract Development! 🎉\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We have learned that:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Foundry is a smart contract development toolchain that simplifies the smart contract development.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Comes with HUGEEE set of tools to compile, deploy, and interact with smart contracts.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"At Level Up, we have identified the five tools that you will commonly use in Foundry. These include:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"1. Create a Foundry project\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"forge init\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"2. Compiling\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"forge build\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"3. Initializing a local blockchain on Foundry\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"anvil\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"4. Contract Deployment\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"forge create <CONTRACT_NAME> --rpc-url <NETWORK> --account <ACCOUNT_NAME>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"5. Contract Interaction\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"cast [options] <CONTRACT_FUNCTION> [args]\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now that you have grasped Level Zero of Foundry, you are ready to dive into the world of smart contract development! 🚀\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "private-smart-contracts-with-solidity-and-circom",
    "name": "Private Smart Contracts with Solidity & Circom",
    "index": 4,
    "summary": "Get started with developing privacy applications by combining Circuits and Smart Contracts.",
    "author": "FilosofiaCodigo",
    "authorIcon": "https://avatars.githubusercontent.com/u/707484?s=96&v=4",
    "authorLink": "https://x.com/FilosofiaCodigo",
    "published": "Sep 04, 2024",
    "readTime": "15 min read",
    "labels": [
      "ZK"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"ZK enables the development of applications with both private data and private execution. This opens the door to many new use cases, like the one we'll create in this guide: an anonymous and secure voting system combining Circom and Solidity.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Circom and dependencies\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you don't have Circom installed yet, install it with the following commands. I'm using node v20, but it should work with other versions as well.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\\ngit clone https://github.com/iden3/circom.git\\ncd circom\\ncargo build --release\\ncargo install --path circom\\nnpm install -g snarkjs\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We'll also use the Circom libraries where the Poseidon function that we'll be using is located.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"git clone https://github.com/iden3/circomlib.git\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. Public key creation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The method we will use to conduct anonymous and secure voting is by proving that we are part of a group without revealing our identity. For example, I will vote for the president of Honduras, demonstrating that I am a Honduran without revealing which specific Honduran I am. This is called \\\"proof of inclusion in a set.\\\"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The most practical way to achieve this in zk and blockchain is through Merkle trees. We will place the voters as leaves in the tree and prove that we are one of them without disclosing which one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Since the tree is public, we will use a set of public-private key pairs so that each voter can cast their vote only once.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You might wonder if we can use the public keys from our Ethereum wallet (e.g., from MetaMask). In future guides like this one, I'll address that topic just as I did with noir. To reach that point, you'll need the fundamentals from this guide. So stay tuned and follow \", _jsx(_components.a, {\n        href: \"https://x.com/levelupweb3\",\n        children: \"LevelUp on X\"\n      }), \"!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, let's create the public keys for the following private keys using the circuit privateKeyHasher.circom below:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"111\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"222\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"333\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"444\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"privateKeyHasher.circom\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"pragma circom 2.0.0;\\n\\ninclude \\\"circomlib/circuits/poseidon.circom\\\";\\n\\ntemplate privateKeyHasher() {\\n    signal input privateKey;\\n    signal output publicKey;\\n    component poseidonComponent;\\n    poseidonComponent = Poseidon(1);\\n    poseidonComponent.inputs[0] <== privateKey;\\n    publicKey <== poseidonComponent.out;\\n    log(publicKey);\\n}\\n\\ncomponent main = privateKeyHasher();\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"input.json\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n    \\\"privateKey\\\": \\\"111\\\"\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Compile and compute the circuit with the commands below, and you'll see the result in the terminal.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"circom privateKeyHasher.circom --r1cs --wasm --sym --c\\nnode privateKeyHasher_js/generate_witness.js privateKeyHasher_js/privateKeyHasher.wasm input.json witness.wtns\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The result of the 4 private keys should be as follows:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Private key\"\n          }), _jsx(_components.th, {\n            children: \"Public key\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"111\"\n          }), _jsx(_components.td, {\n            children: \"13377623690824916797327209540443066247715962236839283896963055328700043345550\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"222\"\n          }), _jsx(_components.td, {\n            children: \"3370092681714607727019534888747304108045661953819543369463810453568040251648\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"333\"\n          }), _jsx(_components.td, {\n            children: \"19430878135540641438890585969007029177622584902384053006985767702837167003933\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"444\"\n          }), _jsx(_components.td, {\n            children: \"2288143249026782941992289125994734798520452235369536663078162770881373549221\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Is it necessary to do this through Circom? The answer is no. By using Circom, we're performing a lot of unnecessary computation. For now, we're doing it this way to ensure that the implementation of the Poseidon hashing algorithm we'll use later is compatible. This is not recommended for production projects where you should use a hashing algorithm written in Javascript that matches the exact implementation as your contract and circuit.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Tree Creation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we have the four leaves of our tree positioned as follows\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"└─ ???\\n   ├─ ???\\n   │  ├─ 13377623690824916797327209540443066247715962236839283896963055328700043345550\\n   │  └─ 3370092681714607727019534888747304108045661953819543369463810453568040251648\\n   └─ ???\\n      ├─ 19430878135540641438890585969007029177622584902384053006985767702837167003933\\n      └─ 2288143249026782941992289125994734798520452235369536663078162770881373549221\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, we're going to generate the Merkle tree branch by branch. Remember that Merkle trees are generated by hashing each of their leaves and branches in pairs until reaching the root.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To generate the complete tree, we'll execute the following function that hashes two leaves to generate their root. We'll do this a total of 3 times because that's what's needed to obtain the root of a tree with 4 leaves: \", _jsx(_components.code, {\n        children: \"root = hash(hash(A, B), hash(C, D))\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"hashLeaves.circom\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"pragma circom 2.0.0;\\n\\ninclude \\\"circomlib/circuits/poseidon.circom\\\";\\n\\ntemplate hashLeaves() {\\n    signal input leftLeaf;\\n    signal input rightLeaf;\\n    signal output root;\\n    component poseidonComponent;\\n    poseidonComponent = Poseidon(2);\\n    poseidonComponent.inputs[0] <== leftLeaf;\\n    poseidonComponent.inputs[1] <== rightLeaf;\\n    root <== poseidonComponent.out;\\n    log(root);\\n}\\n\\ncomponent main = hashLeaves();\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here are the inputs needed to generate the first branch. Similarly, you can generate the other branch and the root.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"input.json\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n    \\\"leftLeaf\\\": \\\"13377623690824916797327209540443066247715962236839283896963055328700043345550\\\",\\n    \\\"rightLeaf\\\": \\\"3370092681714607727019534888747304108045661953819543369463810453568040251648\\\"\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Similar to the previous step, with the following commands, the circuit will be compiled and the root will be printed given its two leaves.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"circom hashLeaves.circom --r1cs --wasm --sym --c\\nnode hashLeaves_js/generate_witness.js hashLeaves_js/hashLeaves.wasm input.json witness.wtns\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is how the full tree looks like:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"└─ 172702405816516791996779728912308790882282610188111072512380034048458433129\\n   ├─ 8238706810845716733547504554580992539732197518335350130391048624023669338026\\n   │  ├─ 13377623690824916797327209540443066247715962236839283896963055328700043345550\\n   │  └─ 3370092681714607727019534888747304108045661953819543369463810453568040251648\\n   └─ 11117482755699627218224304590393929490559713427701237904426421590969988571596\\n      ├─ 19430878135540641438890585969007029177622584902384053006985767702837167003933\\n      └─ 2288143249026782941992289125994734798520452235369536663078162770881373549221\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. Generate Proof of an Anonymous Vote\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To generate a vote, we need to pass the following parameters to the circuit:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"privateKey\"\n        }), \": The user's private key.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"root\"\n        }), \": The root of the tree ensures that we are operating within the correct set. Additionally, for clarity, we could add the contract and the chain where the vote will be executed. This variable will be public and accessible to the smart contract.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"proposalId\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"vote\"\n        }), \": The vote chosen by the user.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"pathElements\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"pathIndices\"\n        }), \": The minimal information needed to reconstruct the root. This includes \", _jsx(_components.code, {\n          children: \"pathElements\"\n        }), \", which are the leaf or branch nodes, and pathIndices, which show which path to take for hashing, where 0 represents nodes on the left and 1 represents nodes on the right.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"proveVote.circom\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"pragma circom 2.0.0;\\n\\ninclude \\\"circomlib/circuits/poseidon.circom\\\";\\n\\ntemplate switchPosition() {\\n    signal input in[2];\\n    signal input s;\\n    signal output out[2];\\n\\n    s * (1 - s) === 0;\\n    out[0] <== (in[1] - in[0])*s + in[0];\\n    out[1] <== (in[0] - in[1])*s + in[1];\\n}\\n\\ntemplate privateKeyHasher() {\\n    signal input privateKey;\\n    signal output publicKey;\\n    component poseidonComponent;\\n    poseidonComponent = Poseidon(1);\\n    poseidonComponent.inputs[0] <== privateKey;\\n    publicKey <== poseidonComponent.out;\\n}\\n\\ntemplate nullifierHasher() {\\n    signal input root;\\n    signal input privateKey;\\n    signal input proposalId;\\n    signal output nullifier;\\n    component poseidonComponent;\\n    poseidonComponent = Poseidon(3);\\n    poseidonComponent.inputs[0] <== root;\\n    poseidonComponent.inputs[1] <== privateKey;\\n    poseidonComponent.inputs[2] <== proposalId;\\n    nullifier <== poseidonComponent.out;\\n}\\n\\ntemplate proveVote(levels) {\\n    signal input privateKey;\\n    signal input root;\\n    signal input proposalId;\\n    signal input vote;\\n    signal input pathElements[levels];\\n    signal input pathIndices[levels];\\n    signal output nullifier;\\n\\n    signal leaf;\\n    component hasherComponent;\\n    hasherComponent = privateKeyHasher();\\n    hasherComponent.privateKey <== privateKey;\\n    leaf <== hasherComponent.publicKey;\\n\\n    component selectors[levels];\\n    component hashers[levels];\\n\\n    signal computedPath[levels];\\n\\n    for (var i = 0; i < levels; i++) {\\n        selectors[i] = switchPosition();\\n        selectors[i].in[0] <== i == 0 ? leaf : computedPath[i - 1];\\n        selectors[i].in[1] <== pathElements[i];\\n        selectors[i].s <== pathIndices[i];\\n\\n        hashers[i] = Poseidon(2);\\n        hashers[i].inputs[0] <== selectors[i].out[0];\\n        hashers[i].inputs[1] <== selectors[i].out[1];\\n        computedPath[i] <== hashers[i].out;\\n    }\\n    root === computedPath[levels - 1];\\n\\n    component nullifierComponent;\\n    nullifierComponent = nullifierHasher();\\n    nullifierComponent.root <== root;\\n    nullifierComponent.privateKey <== privateKey;\\n    nullifierComponent.proposalId <== proposalId;\\n    nullifier <== nullifierComponent.nullifier;\\n}\\n\\ncomponent main {public [root, proposalId, vote]} = proveVote(2);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"input.json\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n    \\\"privateKey\\\": \\\"111\\\",\\n    \\\"root\\\": \\\"172702405816516791996779728912308790882282610188111072512380034048458433129\\\",\\n    \\\"proposalId\\\": \\\"0\\\",\\n    \\\"vote\\\": \\\"1\\\",\\n    \\\"pathElements\\\": [\\\"3370092681714607727019534888747304108045661953819543369463810453568040251648\\\", \\\"11117482755699627218224304590393929490559713427701237904426421590969988571596\\\"],\\n    \\\"pathIndices\\\": [\\\"0\\\",\\\"0\\\"]\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's test if everything works correctly:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"} language=\\\"cpp\\\"/>circom proveVote.circom --r1cs --wasm --sym --c node proveVote_js/generate_witness.js proveVote_js/proveVote.wasm input.json witness.wtns\"\n      }), \"} language=\\\"bash\\\"/>\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If there were no issues, nothing should be printed in the terminal.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. Verify an on-chain vote, from Soldity\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With the following commands, we carry out the initial ceremony, also known as the trusted setup.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"snarkjs powersoftau new bn128 12 pot12_0000.ptau -v\\nsnarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\\\"First contribution\\\" -v\\nsnarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v\\nsnarkjs groth16 setup proveVote.r1cs pot12_final.ptau proveVote_0000.zkey\\nsnarkjs zkey contribute proveVote_0000.zkey proveVote_0001.zkey --name=\\\"1st Contributor Name\\\" -v\\nsnarkjs zkey export verificationkey proveVote_0001.zkey verification_key.json\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, we generate the verifier contract in Solidity.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"snarkjs zkey export solidityverifier proveVote_0001.zkey verifier.sol\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Upon executing this command, a verifier contract will be generated in the file verifier.sol. Now deploy that contract on-chain. On this example, we'll use Remix, however you can use foundry to deploy it on Scroll Sepolia as follows.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create --rpc-url https://scroll-testnet-public.unifra.io --private-key <PRIVATE_KEY> verifier.sol:Groth16Verifier\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, deploy the following contract on-chain, which contains the logic for voting and proof verification. Pass the address of the verifier contract we just deployed as a parameter in the constructor.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"CircomVoter.sol\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface ICircomVerifier {\\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[4] calldata _pubSignals) external view returns (bool);\\n}\\n\\ncontract CircomVoter {\\n    ICircomVerifier circomVerifier;\\n    uint public publicInput;\\n\\n    struct Proposal {\\n        string description;\\n        uint deadline;\\n        uint forVotes;\\n        uint againstVotes;\\n    }\\n\\n    uint merkleRoot;\\n    uint proposalCount;\\n    mapping (uint proposalId => Proposal) public proposals;\\n    mapping (uint nullifier => bool isNullified) public nullifiers;\\n\\n    constructor(uint _merkleRoot, address circomVeriferAddress) {\\n        merkleRoot = _merkleRoot;\\n        circomVerifier = ICircomVerifier(circomVeriferAddress);\\n    }\\n\\n    function propose(string memory description, uint deadline) public {\\n        proposals[proposalCount] = Proposal(description, deadline, 0, 0);\\n        proposalCount += 1;\\n    }\\n\\n    function castVote(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[4] calldata _pubSignals) public {\\n        circomVerifier.verifyProof(_pA, _pB, _pC, _pubSignals);\\n        uint nullifier = _pubSignals[0];\\n        uint merkleRootPublicInput = _pubSignals[1];\\n        uint proposalId = uint(_pubSignals[2]);\\n        uint vote = uint(_pubSignals[3]);\\n\\n        require(block.timestamp < proposals[proposalId].deadline, \\\"Voting period is over\\\");\\n        require(merkleRoot == merkleRootPublicInput, \\\"Invalid merke root\\\");\\n        require(!nullifiers[nullifier], \\\"Vote already casted\\\");\\n\\n        nullifiers[nullifier] = true;\\n\\n        if(vote == 1)\\n            proposals[proposalId].forVotes += 1;\\n        else if (vote == 2)\\n            proposals[proposalId].againstVotes += 1;\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now deploy it on-chain. Again, if you're using forge on Scroll Sepolia you can do it with the following command.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create CircomVoter.sol:CircomVoter --rpc-url https://scroll-testnet-public.unifra.io --private-key <PRIVATE_KEY> --constructor-args <VERIFIER_ADDRESS>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, create the first proposal for voting by calling the propose() function. For example, you can test by creating a vote with \\\"Should we eat pizza?\\\" as the description and with 1811799232 as the deadline, which expires in 2027.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, let's generate a proof in the format required to verify it in Remix.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"snarkjs groth16 prove proveVote_0001.zkey witness.wtns proof.json public.json\\nsnarkjs groth16 verify verification_key.json public.json proof.json\\nsnarkjs generatecall\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's pass the result from the terminal as a parameter in Remix, and we'll see how the vote was executed by accessing the data of proposal 0 through the proposals mapping.\"\n    }), \"\\n\", _jsx(\"div\", {\n      className: \"text-center\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vxtljhmmkyv2zh30i7tz.png\",\n          alt: \"Votos anónimos con Circom y Solidity\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We observe that our vote was counted without revealing who the sender was. Try to cast the same vote again, and you'll see that it won't be possible—the transaction will revert. This is because we nullified the vote so that each voter can only cast one vote.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Wrapping Up\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this guide, we combined Circom and Solidity to develop a private voting system. We began by creating private keys using Poseidon, a ZK-friendly hashing function, and then moved on to constructing a Merkle tree for managing the set of eligible voters. Following that, we generated proofs and verified them in a Solidity contract. This approach ensures the validity of all votes by verifying them on-chain, while also providing voters with anonymity guarantees by keeping their identity private through ZK proofs.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Please note that in this guide, we did everything via the CLI. UI architecture in ZK private applications is very important because we need to ensure that users' data is never exposed to the internet. We cover that in the \", _jsx(_components.a, {\n        href: \"https://www.levelup.xyz/content/privacy-interfaces-on-soldity-zk-wasm\",\n        children: \"next article\"\n      }), \", where we use ZK proofs with WASM for fast proving.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "privacy-interfaces-on-soldity-zk-wasm",
    "name": "Privacy Interfaces on Solidity & zk-WASM",
    "index": 5,
    "summary": "Keep users' data safe by generating proofs in the browser, on Javascript.",
    "author": "FilosofiaCodigo",
    "authorIcon": "https://avatars.githubusercontent.com/u/707484?s=96&v=4",
    "authorLink": "https://x.com/FilosofiaCodigo",
    "published": "Sep 04, 2024",
    "readTime": "15 min read",
    "labels": [
      "ZK"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    em: \"em\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Prefer to see the complete code? \", _jsx(_components.a, {\n        href: \"https://github.com/Turupawn/zkwasm-demo\",\n        children: \"Head to Github\"\n      }), \" to find all the code mentioned in this guide.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Blockchain users need privacy in their finances, identity, social networks, and more. But web3 is transparent and public. So, how can users protect their anonymity in such an environment?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The key is to create computation proofs in a place where only the user has access, where the user's data is secure. That place is precisely the browser, before the user's data touches the internet. This is what we call client-side proving or browser proving.\"\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/zn2yfuqumjippdbdlxt4.png\",\n        alt: \"zk private inputs diagram\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"In order to keep the parameters private, they should never get out of the browser\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's get to know, with a practical and simple example, how to create interfaces that make use of zk-wasm, the technology that makes this possible.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Dependencies\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For this example, we will use Circom. If you don't have it installed, you can do so with the following commands.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\\ngit clone https://github.com/iden3/circom.git\\ncd circom\\ncargo build --release\\ncargo install --path circom\\nnpm install -g snarkjs\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. Create a circuit\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We'll create a very simple example: generating a computation proof for a multiplication a*b=c while keeping a and b private. If you're interested in a more advanced example with a real use case, visit my \", _jsx(_components.a, {\n        href: \"https://www.levelup.xyz/content/private-smart-contracts-with-solidity-and-circom\",\n        children: \"my previous article\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Circom allows us to create circuits that generate execution proofs while obfuscating the parameters.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Start by creating the following circuit:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"myCircuit.circom\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"pragma circom 2.0.0;\\n\\ntemplate Multiplier() {\\n  signal input a;\\n  signal input b;\\n  signal output c;\\n  c <== a*b;\\n}\\n\\ncomponent main = Multiplier();\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now compile it and generate the artifacts that we will use later.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"circom myCircuit.circom --r1cs --wasm --sym\\nsnarkjs powersoftau new bn128 12 pot12_0000.ptau -v\\nsnarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\\\"First contribution\\\" -v\\nsnarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v\\nsnarkjs groth16 setup myCircuit.r1cs pot12_final.ptau myCircuit_0000.zkey\\nsnarkjs zkey contribute myCircuit_0000.zkey myCircuit_0001.zkey --name=\\\"1st Contributor Name\\\" -v\\nsnarkjs zkey export verificationkey myCircuit_0001.zkey verification_key.json\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Deploy the contracts\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The following command will generate a verifier contract in the verifier.sol file. Deploy it on a blockchain of your choice. This contract contains the verifyProof() function, which takes a computation proof made with our circuit as a parameter and returns true if the proof is correct.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: This contract is compatible with L1 EVMs, optimistic L2s, but in terms of ZK L2s, it is currently only compatible with Scroll.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"snarkjs zkey export solidityverifier myCircuit_0001.zkey verifier.sol\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example you can deploy it on Scroll Sepolia by using Foundry.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create --rpc-url https://scroll-testnet-public.unifra.io --private-key <PRIVATE_KEY> verifier.sol:Groth16Verifier\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now deploy the following custom logic contract, passing the address of the verifier contract we deployed earlier as a constructor parameter. In this contract, you can add any desired logic in Solidity, such as vote counting in a voting system or the reception or sending of ERC20 tokens in an anonymous DeFi system. In this example, we will only store the result of the multiplication we did in our circuit.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"CircomCustomLogic.sol\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface ICircomVerifier {\\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[1] calldata _pubSignals) external view returns (bool);\\n}\\n\\ncontract CircomCustomLogic {\\n    ICircomVerifier circomVerifier;\\n    uint public publicInput;\\n\\n    constructor(address circomVeriferAddress) {\\n        circomVerifier = ICircomVerifier(circomVeriferAddress);\\n    }\\n\\n    function sendProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[1] calldata _pubSignals) public {\\n        // ZK verification\\n        circomVerifier.verifyProof(_pA, _pB, _pC, _pubSignals);\\n\\n        // Your custom logic\\n        publicInput = _pubSignals[0];\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now deploy it on-chain. If you're using forge on Scroll Sepolia you can do it with the following command.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create CircomCustomLogic.sol:CircomCustomLogic --rpc-url https://scroll-testnet-public.unifra.io --private-key <PRIVATE_KEY> --constructor-args <VERIFIER_ADDRESS>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. Build a frontend\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now create this file structure:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"js/\\n  blockchain_stuff.js\\n  snarkjs.min.js\\njson_abi/\\n  MyContract.json\\nzk_artifacts/\\n  myCircuit_final.zkey\\n  myCircuit.wasm\\n  verification_key.json\\nindex.html\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"js/snarkjs.min.js\"\n        }), \": Download \", _jsx(_components.a, {\n          href: \"https://github.com/iden3/snarkjs/releases/tag/v0.7.4\",\n          children: \"snarkjs-0.7.4.zip\"\n        }), \", which contains the \", _jsx(_components.code, {\n          children: \"snarkjs.min.js\"\n        }), \" library under the \", _jsx(_components.code, {\n          children: \"build/\"\n        }), \" directory.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"json_abi/MyContract.json\"\n        }), \": the \", _jsx(_components.code, {\n          children: \"CircomCustomLogic\"\n        }), \" contract ABI we just launched, for example on Remix, you can get it by clicking the \\\"ABI\\\" button on the compiler tab.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"zk_artifacts\"\n        }), \": put in this folder the files we generated previously. Not: Change the \", _jsx(_components.code, {\n          children: \"myCircuit_0002.zkey\"\n        }), \" name for \", _jsx(_components.code, {\n          children: \"myCircuit_final.zkey\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"index.html\"\n        }), \" y \", _jsx(_components.code, {\n          children: \"js/blockchain_stuff.js\"\n        }), \" are content is detailed below.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The HTML file below describes the graphical interface where we will input the numbers to be multiplied. In a production environment, I would recommend using a frontend framework like React, Vue, or Angular. This example is for educational purposes.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"index.html\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-html\",\n        children: \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n  <meta charset=\\\"utf-8\\\">\\n</head>\\n<body>\\n  <input id=\\\"connect_button\\\" type=\\\"button\\\" value=\\\"Connect\\\" onclick=\\\"connectWallet()\\\" style=\\\"display: none\\\"></input>\\n  <p id=\\\"account_address\\\" style=\\\"display: none\\\"></p>\\n  <p id=\\\"web3_message\\\"></p>\\n  <p id=\\\"contract_state\\\"></p>\\n  <input type=\\\"input\\\"  value=\\\"\\\" id=\\\"a\\\"></input>\\n  <input type=\\\"input\\\"  value=\\\"\\\" id=\\\"b\\\"></input>\\n  <input type=\\\"button\\\" value=\\\"Send Proof\\\" onclick=\\\"_sendProof()\\\"></input>\\n  <br>\\n  <script type=\\\"text/javascript\\\" src=\\\"https://cdnjs.cloudflare.com/ajax/libs/web3/1.3.5/web3.min.js\\\"></script>\\n  <script type=\\\"text/javascript\\\" src=\\\"js/blockchain_stuff.js\\\"></script>\\n  <script type=\\\"text/javascript\\\" src=\\\"js/snarkjs.min.js\\\"></script>\\n</body>\\n</html>\\n\\n<script>\\n  function _sendProof()\\n  {\\n    a = document.getElementById(\\\"a\\\").value\\n    b = document.getElementById(\\\"b\\\").value\\n    sendProof(a, b)\\n  }\\n</script>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Our JavaScript file contains both the logic for generating zk proofs using the snark.js library and the blockchain logic using the web3.js library. In a production environment, I would recommend using TypeScript instead of plain JavaScript; this example is for educational purposes.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"js/blockchain_stuff.js\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"const NETWORK_ID = 534351\\n\\nconst MY_CONTRACT_ADDRESS = \\\"0xFdAFc996a60bC5fEB307AAF81b1eD0A34a954F06\\\"\\nconst MY_CONTRACT_ABI_PATH = \\\"./json_abi/MyContract.json\\\"\\nvar my_contract\\n\\nvar accounts\\nvar web3\\n\\nfunction metamaskReloadCallback() {\\n  window.ethereum.on('accountsChanged', (accounts) => {\\n    document.getElementById(\\\"web3_message\\\").textContent=\\\"Se cambió el account, refrescando...\\\";\\n    window.location.reload()\\n  })\\n  window.ethereum.on('networkChanged', (accounts) => {\\n    document.getElementById(\\\"web3_message\\\").textContent=\\\"Se el network, refrescando...\\\";\\n    window.location.reload()\\n  })\\n}\\n\\nconst getWeb3 = async () => {\\n  return new Promise((resolve, reject) => {\\n    if(document.readyState==\\\"complete\\\")\\n    {\\n      if (window.ethereum) {\\n        const web3 = new Web3(window.ethereum)\\n        window.location.reload()\\n        resolve(web3)\\n      } else {\\n        reject(\\\"must install MetaMask\\\")\\n        document.getElementById(\\\"web3_message\\\").textContent=\\\"Error: Porfavor conéctate a Metamask\\\";\\n      }\\n    }else\\n    {\\n      window.addEventListener(\\\"load\\\", async () => {\\n        if (window.ethereum) {\\n          const web3 = new Web3(window.ethereum)\\n          resolve(web3)\\n        } else {\\n          reject(\\\"must install MetaMask\\\")\\n          document.getElementById(\\\"web3_message\\\").textContent=\\\"Error: Please install Metamask\\\";\\n        }\\n      });\\n    }\\n  });\\n};\\n\\nconst getContract = async (web3, address, abi_path) => {\\n  const response = await fetch(abi_path);\\n  const data = await response.json();\\n\\n  const netId = await web3.eth.net.getId();\\n  contract = new web3.eth.Contract(\\n    data,\\n    address\\n    );\\n  return contract\\n}\\n\\nasync function loadDapp() {\\n  metamaskReloadCallback()\\n  document.getElementById(\\\"web3_message\\\").textContent=\\\"Please connect to Metamask\\\"\\n  var awaitWeb3 = async function () {\\n    web3 = await getWeb3()\\n    web3.eth.net.getId((err, netId) => {\\n      if (netId == NETWORK_ID) {\\n        var awaitContract = async function () {\\n          my_contract = await getContract(web3, MY_CONTRACT_ADDRESS, MY_CONTRACT_ABI_PATH)\\n          document.getElementById(\\\"web3_message\\\").textContent=\\\"You are connected to Metamask\\\"\\n          onContractInitCallback()\\n          web3.eth.getAccounts(function(err, _accounts){\\n            accounts = _accounts\\n            if (err != null)\\n            {\\n              console.error(\\\"An error occurred: \\\"+err)\\n            } else if (accounts.length > 0)\\n            {\\n              onWalletConnectedCallback()\\n              document.getElementById(\\\"account_address\\\").style.display = \\\"block\\\"\\n            } else\\n            {\\n              document.getElementById(\\\"connect_button\\\").style.display = \\\"block\\\"\\n            }\\n          });\\n        };\\n        awaitContract();\\n      } else {\\n        document.getElementById(\\\"web3_message\\\").textContent=\\\"Please connect to Scroll Testnet\\\";\\n      }\\n    });\\n  };\\n  awaitWeb3();\\n}\\n\\nasync function connectWallet() {\\n  await window.ethereum.request({ method: \\\"eth_requestAccounts\\\" })\\n  accounts = await web3.eth.getAccounts()\\n  onWalletConnectedCallback()\\n}\\n\\nloadDapp()\\n\\nconst onContractInitCallback = async () => {\\n  var publicInput = await my_contract.methods.publicInput().call()\\n  var contract_state = \\\"Public input: \\\" + publicInput\\n  document.getElementById(\\\"contract_state\\\").textContent = contract_state;\\n}\\n\\nconst onWalletConnectedCallback = async () => {\\n}\\n\\n\\n//// Functions ////\\n\\nconst sendProof = async (a, b) => {\\n  document.getElementById(\\\"web3_message\\\").textContent=\\\"Generating proof...\\\";\\n\\n  const { proof, publicSignals } = await snarkjs.groth16.fullProve( { a: a, b: b}, \\\"../zk_artifacts/myCircuit.wasm\\\", \\\"../zk_artifacts/myCircuit_final.zkey\\\");\\n\\n  const vkey = await fetch(\\\"../zk_artifacts/verification_key.json\\\").then( function(res) {\\n    return res.json();\\n  });\\n\\n  const res = await snarkjs.groth16.verify(vkey, publicSignals, proof);\\n\\n  pA = proof.pi_a\\n  pA.pop()\\n  pB = proof.pi_b\\n  pB.pop()\\n  pC = proof.pi_c\\n  pC.pop()\\n\\n  document.getElementById(\\\"web3_message\\\").textContent=\\\"Proof generated please confirm transaction.\\\";\\n\\n  const result = await my_contract.methods.sendProof(pA, pB, pC, publicSignals)\\n  .send({ from: accounts[0], gas: 0, value: 0 })\\n  .on('transactionHash', function(hash){\\n    document.getElementById(\\\"web3_message\\\").textContent=\\\"Executing...\\\";\\n  })\\n  .on('receipt', function(receipt){\\n    document.getElementById(\\\"web3_message\\\").textContent=\\\"Success.\\\";    })\\n  .catch((revertReason) => {\\n    console.log(\\\"ERROR! Transaction reverted: \\\" + revertReason.receipt.transactionHash)\\n  });\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. Try the app\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Before testing, you need to adjust the variables NETWORK_ID and MY_CONTRACT_ADDRESS in js/blockchain_stuff.js. NETWORK_ID is the unique identifier of the chain you are using. In this example, I'm using 534351, which represents the Scroll Sepolia Testnet. If you wish to use another chain, I recommend finding the identifier on \", _jsx(_components.a, {\n        href: \"https://chainlist.org/\",\n        children: \"chainlist\"\n      }), \". Also, place the address of the CircomCustomLogic contract you just deployed into the MY_CONTRACT_ADDRESS variable.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now you're ready to test the application on any web server. I typically use lite-server for development. Here's how you can install it and start a server, just make sure you are in the project folder:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"npm install -g lite-server #para instalar\\nlite-server #para levantar el servidor\\n\"\n      })\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a24eo00jc3rbfxe8bgpx.png\",\n        alt: \"ejemplo de circuito multiplicador zk\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Once everything is ready this is how your app should look like\"\n        })\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "huracan",
    "name": "🌀Huracan",
    "index": 6,
    "summary": "Learn ZK by Deploying a Battle Tested Project.",
    "author": "FilosofiaCodigo",
    "authorIcon": "https://avatars.githubusercontent.com/u/707484?s=96&v=4",
    "authorLink": "https://x.com/FilosofiaCodigo",
    "published": "Sep 04, 2024",
    "readTime": "15 min read",
    "labels": [
      "ZK",
      "DeFi"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\n/*\n## Table of Contents\n\n1. [How Huracán Works](#1-how-huracán-works)\n1. [The Circuit](#2-the-circuit)\n1. [The Contracts](#3-the-contracts)\n1. [The Frontend](#4-the-frontend)\n1. [The Relayer](#5-the-relayer)\n1. [How to Take Huracán to Production](#6-how-to-take-huracán-to-production)\n1. [Ideas for Further Exploration](#7-ideas-for-further-exploration)\n*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    em: \"em\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    code: \"code\",\n    pre: \"pre\",\n    h3: \"h3\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Prefer to see the complete code? \", _jsx(_components.a, {\n        href: \"https://github.com/Turupawn/Huracan\",\n        children: \"Head to Github\"\n      }), \" to find all the code mentioned in this guide.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Learning about ZK today is not an easy task. It's a new technology with limited documentation. Huracan was born out of my own need to learn about ZK in a practical way, geared towards developers and engineers.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Huracan is a fully functional project capable of performing private transactions on Ethereum and EVM blockchains. It's based on battle tested privacy projects but includes only the minimal code to simplify the learning process. We will cover how this technology can be adapted to new use cases and future regulations. Additionally, at the end of the article, I share what is needed to take this project from testnet to real production use.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By the end of this guide, you'll be able to research other projects of the same nature and understand how they are built.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.em, {\n        children: \"How Huracán is Built:\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Circom circuits\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Poseidon hash\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Deposit and withdrawal logic in Solidity\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Merkle tree generation in JS and Solidity, verification in Circom\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"HTML and JS vanilla Frontend\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"web3.js for web3 interaction and snarkjs for browser proving (zk-WASM)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Relayer with ethers.js 6 and Express to preserve user anonymity\"\n      }), \"\\n\"]\n    }), \"\\n\", \"\\n\", _jsx(_components.h2, {\n      children: \"1. How Huracán Works\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Huracán is a DeFi tool that protects the identity of its users using a technique known as \", _jsx(_components.em, {\n        children: \"anonymous inclusion proofs\"\n      }), \" to perform what is commonly called a \", _jsx(_components.em, {\n        children: \"mixer\"\n      }), \". This system can prove that a user has deposited ether into a contract without revealing which one he is.\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/if5yhd2ef1vwr0bujxkz.png\",\n        alt: \"Depositing in Huracán\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Each user who deposits Ether into Huracán is added as a leaf in a Merkle tree within the contract\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To achieve this, we need a smart contract where funds are deposited, which will generate a Merkle tree where each leaf represents a depositor. Additionally, we will need a circuit that generates inclusion proofs to keep the user anonymous when withdrawing funds. We also need a relayer that will execute the transaction on behalf of the anonymous user to protect their privacy.\"\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/igrb94o5cidddo3c8s5z.png\",\n        alt: \"Withdrawing from Huracán\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Users can later withdraw their funds by proving they are part of the Merkle tree without revealing which leaf belongs to them\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Below is the code, a brief explanation, and the supporting materials necessary to build and launch your own privacy-focused project.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. The Circuit\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.em, {\n        children: [\"Supporting Material: \", _jsx(_components.a, {\n          href: \"https://www.levelup.xyz/content/private-smart-contracts-with-solidity-and-circom\",\n          children: \"Private Smart Contracts with Solidity and Circom\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The circuit is responsible for proving that you are part of the Merkle tree, meaning you are one of the depositors without revealing which one you are since you keep the parameters private while generating an inclusion proof that can be verified by a smart contract. Which parameters are kept private? During the deposit, we hash a private key and a nullifier to create a new leaf in the tree. The private key is a private parameter that will later serve to prove that you are the owner of that leaf. The nullifier is another parameter whose hash will be passed to the Solidity contract when redeeming funds, preventing a user from withdrawing funds twice in a row (double spend). The rest of the private parameters help the circuit reconstruct the tree and verify that you are part of it.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We start by installing the \", _jsx(_components.code, {\n        children: \"circomlib\"\n      }), \" library, which contains the Poseidon circuits we will be using in this tutorial.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"git clone https://github.com/iden3/circomlib.git\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now we create our \", _jsx(_components.code, {\n        children: \"proveWithdrawal\"\n      }), \" circuit that proves we have deposited in the contract without revealing who we are.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"proveWithdrawal.circom\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"pragma circom 2.0.0;\\n\\ninclude \\\"circomlib/circuits/poseidon.circom\\\";\\n\\ntemplate switchPosition() {\\n    signal input in[2];\\n    signal input s;\\n    signal output out[2];\\n\\n    s * (1 - s) === 0;\\n    out[0] <== (in[1] - in[0])*s + in[0];\\n    out[1] <== (in[0] - in[1])*s + in[1];\\n}\\n\\ntemplate commitmentHasher() {\\n    signal input privateKey;\\n    signal input nullifier;\\n    signal output commitment;\\n    signal output nullifierHash;\\n    component commitmentHashComponent;\\n    commitmentHashComponent = Poseidon(2);\\n    commitmentHashComponent.inputs[0] <== privateKey;\\n    commitmentHashComponent.inputs[1] <== nullifier;\\n    commitment <== commitmentHashComponent.out;\\n    component nullifierHashComponent;\\n    nullifierHashComponent = Poseidon(1);\\n    nullifierHashComponent.inputs[0] <== nullifier;\\n    nullifierHash <== nullifierHashComponent.out;\\n}\\n\\ntemplate proveWithdrawal(levels) {\\n    signal input root;\\n    signal input recipient;\\n    signal input privateKey;\\n    signal input nullifier;\\n    signal input pathElements[levels];\\n    signal input pathIndices[levels];\\n    signal output nullifierHash;\\n\\n    signal leaf;\\n    component commitmentHasherComponent;\\n    commitmentHasherComponent = commitmentHasher();\\n    commitmentHasherComponent.privateKey <== privateKey;\\n    commitmentHasherComponent.nullifier <== nullifier;\\n    leaf <== commitmentHasherComponent.commitment;\\n    nullifierHash <== commitmentHasherComponent.nullifierHash;\\n\\n    component selectors[levels];\\n    component hashers[levels];\\n\\n    signal computedPath[levels];\\n\\n    for (var i = 0; i < levels; i++) {\\n        selectors[i] = switchPosition();\\n        selectors[i].in[0] <== i == 0 ? leaf : computedPath[i - 1];\\n        selectors[i].in[1] <== pathElements[i];\\n        selectors[i].s <== pathIndices[i];\\n\\n        hashers[i] = Poseidon(2);\\n        hashers[i].inputs[0] <== selectors[i].out[0];\\n        hashers[i].inputs[1] <== selectors[i].out[1];\\n        computedPath[i] <== hashers[i].out;\\n    }\\n    root === computedPath[levels - 1];\\n}\\n\\ncomponent main {public [root, recipient]} = proveWithdrawal(2);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To compile the circuit, we need to have both Circom and snarkjs installed. If you don't have them installed, follow the Circom installation guide.\"\n    }), \"\\n\", _jsxs(\"details\", {\n      children: [_jsx(\"summary\", {\n        children: \"Circom installation guide\"\n      }), _jsx(_components.p, {\n        children: \"Run the following commands to install circom and snarkjs.\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\\ngit clone https://github.com/iden3/circom.git\\ncd circom\\ncargo build --release\\ncargo install --path circom\\nnpm install -g snarkjs\\n\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Generate the trusted setup and zk artifacts we will need later on on the frontend.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"circom proveWithdrawal.circom --r1cs --wasm --sym\\nsnarkjs powersoftau new bn128 12 pot12_0000.ptau -v\\nsnarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\\\"First contribution\\\" -v\\nsnarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v\\nsnarkjs groth16 setup proveWithdrawal.r1cs pot12_final.ptau proveWithdrawal_0000.zkey\\nsnarkjs zkey contribute proveWithdrawal_0000.zkey proveWithdrawal_0001.zkey --name=\\\"1st Contributor Name\\\" -v\\nsnarkjs zkey export verificationkey proveWithdrawal_0001.zkey verification_key.json\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can now generate the \", _jsx(_components.code, {\n        children: \"verifier.sol\"\n      }), \" contract.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"snarkjs zkey export solidityverifier proveWithdrawal_0001.zkey verifier.sol\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. The Contracts\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The contracts serve as a guarantee that everything was run correctly. They allow us to keep track of how much has been deposited and verify that the proofs are valid in order to release the funds. It’s important to note that everything happening in the smart contracts is public; this is the part of our system that is not anonymous.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We will use three contracts. The first is the verifier contract that we just generated in the \", _jsx(_components.code, {\n        children: \"verifier.sol\"\n      }), \" file, so go ahead and deploy it now. For example you can use foundry to deploy it on Scroll Sepolia.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create --rpc-url https://scroll-testnet-public.unifra.io --private-key <PRIVATE_KEY> verifier.sol:Groth16Verifier\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The second contract is the Poseidon contract. If you are on Scroll Sepolia, you can simply use the one I've already deployed at \", _jsx(_components.code, {\n        children: \"0x52f28FEC91a076aCc395A8c730dCa6440B6D9519\"\n      }), \". If you want to use another blockchain, expand and follow the steps:\"]\n    }), \"\\n\", _jsxs(\"details\", {\n      children: [_jsx(\"summary\", {\n        children: \"Deploy the Poseidon contract\"\n      }), _jsxs(_components.p, {\n        children: [\"The version of Poseidon we use in our circuit and contract must be exactly compatible. Therefore, we use the version in \", _jsx(_components.code, {\n          children: \"circomlibjs\"\n        }), \" as shown. Just make sure to insert your private key and RPC URL in place of \", _jsx(_components.code, {\n          children: \"YOURPRIVATEKEY\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"YOURRPCURL\"\n        }), \".\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"git clone https://github.com/iden3/circomlibjs.git\\ncd circomlibjs\\nnpm install\\ncd ..\\nnode --input-type=module --eval \\\"import { writeFileSync } from 'fs'; import('./circomlibjs/src/poseidon_gencontract.js').then(({ createCode }) => { const output = createCode(2); writeFileSync('poseidonBytecode', output); })\\\"\\ncast send --rpc-url TUURLRPC --private-key TULLAVEPRIVADA --create $(cat bytecode)\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"On Scroll, I added \", _jsx(_components.code, {\n          children: \"--legacy --gas-price 5000000000\"\n        }), \", probably when you see this video you won't need to add it. In any case you shouldn't need this in other chains. Regardless, this is the command just as I sent it.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-bash\",\n          children: \"cast send --rpc-url TUURLRPC --legacy --gas-price 5000000000 --private-key TULLAVEPRIVADA --create $(cat bytecode)\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now deploy the \", _jsx(_components.code, {\n        children: \"Huracan\"\n      }), \" contract by passing the verifier and poseidon addresses as parameters.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface IPoseidon {\\n    function poseidon(uint[2] memory inputs) external returns(uint[1] memory output);\\n}\\n\\ninterface ICircomVerifier {\\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[3] calldata _pubSignals) external view returns (bool);\\n}\\n\\ncontract Huracan {\\n    ICircomVerifier circomVerifier;\\n    uint nextIndex;\\n    uint public constant LEVELS = 2;\\n    uint public constant MAX_SIZE = 4;\\n    uint public NOTE_VALUE = 0.001 ether;\\n    uint[] public filledSubtrees = new uint[](LEVELS);\\n    uint[] public emptySubtrees = new uint[](LEVELS);\\n    address POSEIDON_ADDRESS;\\n    uint public root;\\n\\n    mapping(uint => uint) public commitments;\\n    mapping(uint => bool) public nullifiers;\\n\\n    event Deposit(uint index, uint commitment);\\n\\n    constructor(address poseidonAddress, address circomVeriferAddress) {\\n        POSEIDON_ADDRESS = poseidonAddress;\\n        circomVerifier = ICircomVerifier(circomVeriferAddress);\\n\\n        for (uint32 i = 1; i < LEVELS; i++) {\\n            emptySubtrees[i] = IPoseidon(POSEIDON_ADDRESS).poseidon([\\n                emptySubtrees[i-1],\\n                0\\n            ])[0];\\n        }\\n    }\\n\\n    function deposit(uint commitment) public payable {\\n        require(msg.value == NOTE_VALUE, \\\"Invalid value sent\\\");\\n        require(nextIndex != MAX_SIZE, \\\"Merkle tree is full. No more leaves can be added\\\");\\n        uint currentIndex = nextIndex;\\n        uint currentLevelHash = commitment;\\n        uint left;\\n        uint right;\\n\\n        for (uint32 i = 0; i < LEVELS; i++) {\\n            if (currentIndex % 2 == 0) {\\n                left = currentLevelHash;\\n                right = emptySubtrees[i];\\n                filledSubtrees[i] = currentLevelHash;\\n            } else {\\n                left = filledSubtrees[i];\\n                right = currentLevelHash;\\n            }\\n            currentLevelHash = IPoseidon(POSEIDON_ADDRESS).poseidon([left, right])[0];\\n            currentIndex /= 2;\\n        }\\n\\n        root = currentLevelHash;\\n        emit Deposit(nextIndex, commitment);\\n        commitments[nextIndex] = commitment;\\n        nextIndex = nextIndex + 1;\\n    }\\n\\n    function withdraw(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[3] calldata _pubSignals) public {\\n        circomVerifier.verifyProof(_pA, _pB, _pC, _pubSignals);\\n        uint nullifierHash = _pubSignals[0];\\n        uint rootPublicInput = _pubSignals[1];\\n        address recipient = address(uint160(_pubSignals[2]));\\n\\n        require(root == rootPublicInput, \\\"Invalid merke root\\\");\\n        require(!nullifiers[nullifierHash], \\\"Vote already casted\\\");\\n\\n        nullifiers[nullifierHash] = true;\\n\\n        (bool sent, bytes memory data) = recipient.call{value: NOTE_VALUE}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n        data;\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now deploy it on-chain. If you're using forge on Scroll Sepolia you can do it with the following command.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"forge create Huracan.sol:Huracan --rpc-url https://scroll-testnet-public.unifra.io --private-key <PRIVATE_KEY> --constructor-args <VERIFIER_ADDRESS>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. The Frontend\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.em, {\n        children: [\"Supporting Material: \", _jsx(_components.a, {\n          href: \"https://www.levelup.xyz/content/privacy-interfaces-on-soldity-zk-wasm\",\n          children: \"Privacy Interfaces with Solidity and zk-WASM\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The frontend is the graphical interface we will be interacting with. In this demonstration, we will be using HTML and vanilla JS so that developers can adapt it to any frontend framework they are using. Something very important is that the frontend must be capable of producing zk proofs without leaking private information over the internet. This is why zk-WASM is crucial, as it allows us to efficiently generate proofs directly in our browser.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, create the following file structure:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"js/\\n  blockchain_stuff.js\\n  snarkjs.min.js\\njson_abi/\\n  Huracan.json\\n  Poseidon.json\\nzk_artifacts/\\n  proveWithdrawal_final.zkey\\n  proveWithdrawal.wasm\\nindex.html\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"js/snarkjs.min.js\"\n        }), \": Download \", _jsx(_components.a, {\n          href: \"https://github.com/iden3/snarkjs/releases/tag/v0.7.4\",\n          children: \"snarkjs-0.7.4.zip\"\n        }), \", which contains the \", _jsx(_components.code, {\n          children: \"snarkjs.min.js\"\n        }), \" library under the \", _jsx(_components.code, {\n          children: \"build/\"\n        }), \" directory.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"json_abi/Huracan.json\"\n        }), \": The ABI of the CircomCustomLogic contract we just deployed (e.g., in Remix). You can obtain it by clicking the \\\"ABI\\\" button in the compilation tab.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"json_abi/Poseidon.json\"\n        }), \": Use \", _jsx(_components.a, {\n          href: \"https://gist.github.com/Turupawn/b89999eb8b00d7507908d6fbf6aa7f0b\",\n          children: \"this file\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"zk_artifacts\"\n        }), \": Place the previously generated artifacts in this folder. Note: Rename \", _jsx(_components.code, {\n          children: \"proveWithdrawal_0001.zkey\"\n        }), \" to \", _jsx(_components.code, {\n          children: \"proveWithdrawal_final.zkey\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"index.html\"\n        }), \", \", _jsx(_components.code, {\n          children: \"js/blockchain_stuff.js\"\n        }), \", and \", _jsx(_components.code, {\n          children: \"js/zk_stuff.js\"\n        }), \": These will be detailed below.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The HTML file contains the interface necessary for users to interact with Huracán.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"index.html\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-html\",\n        children: \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n  <meta charset=\\\"utf-8\\\">\\n</head>\\n<body>\\n  <input id=\\\"connect_button\\\" type=\\\"button\\\" value=\\\"Connect\\\" onclick=\\\"connectWallet()\\\" style=\\\"display: none\\\"></input>\\n  <p id=\\\"account_address\\\" style=\\\"display: none\\\"></p>\\n  <p id=\\\"web3_message\\\"></p>\\n  <p id=\\\"contract_state\\\"></p>\\n  <input type=\\\"input\\\"  value=\\\"\\\" id=\\\"depositPrivateKey\\\" placeholder=\\\"private key\\\"></input>\\n  <input type=\\\"input\\\"  value=\\\"\\\" id=\\\"depositNullifier\\\" placeholder=\\\"nullifier\\\"></input>\\n  <input type=\\\"button\\\" value=\\\"Deposit\\\" onclick=\\\"_deposit()\\\"></input>\\n  <br>\\n  <input type=\\\"input\\\"  value=\\\"\\\" id=\\\"withdrawPrivateKey\\\" placeholder=\\\"private key\\\"></input>\\n  <input type=\\\"input\\\"  value=\\\"\\\" id=\\\"withdrawNullifier\\\" placeholder=\\\"nullifier\\\"></input>\\n  <input type=\\\"input\\\"  value=\\\"\\\" id=\\\"withdrawRecipient\\\" placeholder=\\\"recipient\\\"></input>\\n  <input type=\\\"button\\\" value=\\\"Withdraw\\\" onclick=\\\"_withdraw()\\\"></input>\\n  <br>\\n  <script type=\\\"text/javascript\\\" src=\\\"https://cdnjs.cloudflare.com/ajax/libs/web3/1.3.5/web3.min.js\\\"></script>\\n  <script type=\\\"text/javascript\\\" src=\\\"js/zk_stuff.js\\\"></script>\\n  <script type=\\\"text/javascript\\\" src=\\\"js/blockchain_stuff.js\\\"></script>\\n  <script type=\\\"text/javascript\\\" src=\\\"js/snarkjs.min.js\\\"></script>\\n</body>\\n</html>\\n\\n<script>\\n  function _deposit()\\n  {\\n    depositPrivateKey = document.getElementById(\\\"depositPrivateKey\\\").value\\n    depositNullifier = document.getElementById(\\\"depositNullifier\\\").value\\n    deposit(depositPrivateKey, depositNullifier)\\n  }\\n\\n  function _withdraw()\\n  {\\n    withdrawPrivateKey = document.getElementById(\\\"withdrawPrivateKey\\\").value\\n    withdrawNullifier = document.getElementById(\\\"withdrawNullifier\\\").value\\n    withdrawRecipient = document.getElementById(\\\"withdrawRecipient\\\").value\\n    withdraw(withdrawPrivateKey, withdrawNullifier, withdrawRecipient)\\n  }\\n</script>\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Al logic related to web3 is placed in the following file. This includes browser and wallet connection, state read and contract function calls.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"js/blockchain_stuff.js\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"const NETWORK_ID = 534351\\n\\nconst HURACAN_ADDRESS = \\\"0x8BD32BDC921f5239c0f5d9eaf093B49A67C3b9d0\\\"\\nconst HURACAN_ABI_PATH = \\\"./json_abi/Huracan.json\\\"\\n\\nconst POSEIDON_ADDRESS = \\\"0x52f28FEC91a076aCc395A8c730dCa6440B6D9519\\\"\\nconst POSEIDON_ABI_PATH = \\\"./json_abi/Poseidon.json\\\"\\n\\nconst RELAYER_URL = \\\"http://localhost:8080\\\"\\n\\nvar huracanContract\\nvar poseidonContract\\n\\nvar accounts\\nvar web3\\nlet leaves\\n\\nfunction metamaskReloadCallback() {\\n  window.ethereum.on('accountsChanged', (accounts) => {\\n    document.getElementById(\\\"web3_message\\\").textContent=\\\"Se cambió el account, refrescando...\\\";\\n    window.location.reload()\\n  })\\n  window.ethereum.on('networkChanged', (accounts) => {\\n    document.getElementById(\\\"web3_message\\\").textContent=\\\"Se el network, refrescando...\\\";\\n    window.location.reload()\\n  })\\n}\\n\\nconst getWeb3 = async () => {\\n  return new Promise((resolve, reject) => {\\n    if(document.readyState==\\\"complete\\\")\\n    {\\n      if (window.ethereum) {\\n        const web3 = new Web3(window.ethereum)\\n        window.location.reload()\\n        resolve(web3)\\n      } else {\\n        reject(\\\"must install MetaMask\\\")\\n        document.getElementById(\\\"web3_message\\\").textContent=\\\"Error: Porfavor conéctate a Metamask\\\";\\n      }\\n    }else\\n    {\\n      window.addEventListener(\\\"load\\\", async () => {\\n        if (window.ethereum) {\\n          const web3 = new Web3(window.ethereum)\\n          resolve(web3)\\n        } else {\\n          reject(\\\"must install MetaMask\\\")\\n          document.getElementById(\\\"web3_message\\\").textContent=\\\"Error: Please install Metamask\\\";\\n        }\\n      });\\n    }\\n  });\\n};\\n\\nconst getContract = async (web3, address, abi_path) => {\\n  const response = await fetch(abi_path);\\n  const data = await response.json();\\n\\n  const netId = await web3.eth.net.getId();\\n  contract = new web3.eth.Contract(\\n    data,\\n    address\\n    );\\n  return contract\\n}\\n\\nasync function loadDapp() {\\n  metamaskReloadCallback()\\n  document.getElementById(\\\"web3_message\\\").textContent=\\\"Please connect to Metamask\\\"\\n  var awaitWeb3 = async function () {\\n    web3 = await getWeb3()\\n    web3.eth.net.getId((err, netId) => {\\n      if (netId == NETWORK_ID) {\\n        var awaitContract = async function () {\\n          huracanContract = await getContract(web3, HURACAN_ADDRESS, HURACAN_ABI_PATH)\\n          poseidonContract = await getContract(web3, POSEIDON_ADDRESS, POSEIDON_ABI_PATH)\\n          document.getElementById(\\\"web3_message\\\").textContent=\\\"You are connected to Metamask\\\"\\n          onContractInitCallback()\\n          web3.eth.getAccounts(function(err, _accounts){\\n            accounts = _accounts\\n            if (err != null)\\n            {\\n              console.error(\\\"An error occurred: \\\"+err)\\n            } else if (accounts.length > 0)\\n            {\\n              onWalletConnectedCallback()\\n              document.getElementById(\\\"account_address\\\").style.display = \\\"block\\\"\\n            } else\\n            {\\n              document.getElementById(\\\"connect_button\\\").style.display = \\\"block\\\"\\n            }\\n          });\\n        };\\n        awaitContract();\\n      } else {\\n        document.getElementById(\\\"web3_message\\\").textContent=\\\"Please connect to Goerli\\\";\\n      }\\n    });\\n  };\\n  awaitWeb3();\\n}\\n\\nasync function connectWallet() {\\n  await window.ethereum.request({ method: \\\"eth_requestAccounts\\\" })\\n  accounts = await web3.eth.getAccounts()\\n  onWalletConnectedCallback()\\n}\\n\\nloadDapp()\\n\\nconst onContractInitCallback = async () => {\\n  document.getElementById(\\\"web3_message\\\").textContent=\\\"Reading merkle tree data...\\\";\\n  leaves = []\\n  let i =0\\n  let maxSize = await huracanContract.methods.MAX_SIZE().call()\\n  for(let i=0; i<maxSize; i++)\\n  {\\n    leaves.push(await huracanContract.methods.commitments(i).call())\\n  }\\n  document.getElementById(\\\"web3_message\\\").textContent=\\\"All ready!\\\";\\n}\\n\\nconst onWalletConnectedCallback = async () => {\\n}\\n\\n\\n//// Functions ////\\n\\nconst deposit = async (depositPrivateKey, depositNullifier) => {\\n  let commitment = await poseidonContract.methods.poseidon([depositPrivateKey,depositNullifier]).call()\\n\\n  let value = await huracanContract.methods.NOTE_VALUE().call()\\n\\n  document.getElementById(\\\"web3_message\\\").textContent=\\\"Please confirm transaction.\\\";\\n\\n  const result = await huracanContract.methods.deposit(commitment)\\n    .send({ from: accounts[0], gas: 0, value: value })\\n    .on('transactionHash', function(hash){\\n      document.getElementById(\\\"web3_message\\\").textContent=\\\"Executing...\\\";\\n    })\\n  .on('receipt', function(receipt){\\n    document.getElementById(\\\"web3_message\\\").textContent=\\\"Success.\\\";    })\\n  .catch((revertReason) => {\\n    console.log(\\\"ERROR! Transaction reverted: \\\" + revertReason.receipt.transactionHash)\\n  });\\n}\\n\\nconst withdraw = async (privateKey, nullifier, recipient) => {\\n  document.getElementById(\\\"web3_message\\\").textContent=\\\"Generating proof...\\\";\\n\\n  let commitment = await poseidonContract.methods.poseidon([privateKey,nullifier]).call()\\n\\n  let index = null\\n  for(let i=0; i<leaves.length;i++)\\n  {\\n    if(commitment == leaves[i])\\n    {\\n      index = i\\n    }\\n  }\\n\\n  if(index == null)\\n  {\\n    console.log(\\\"Commitment not found in merkle tree\\\")\\n    return\\n  }\\n\\n  let root = await huracanContract.methods.root().call()\\n  let proof = await getWithdrawalProof(index, privateKey, nullifier, recipient, root)\\n\\n  await sendProofToRelayer(proof.pA, proof.pB, proof.pC, proof.publicSignals)\\n}\\n\\nconst sendProofToRelayer = async (pA, pB, pC, publicSignals) => {\\n  fetch(RELAYER_URL + \\\"/relay?pA=\\\" + pA + \\\"&pB=\\\" + pB + \\\"&pC=\\\" + pC + \\\"&publicSignals=\\\" + publicSignals)\\n  .then(res => res.json())\\n  .then(out =>\\n    console.log(out))\\n  .catch();\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Finally, the file that contains all ZK logic. Capable of generating ZK proofs.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"js/zk_stuff.js\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"async function getMerklePath(leaves) {\\n  if (leaves.length === 0) {\\n    throw new Error('Leaves array is empty');\\n  }\\n\\n  let layers = [leaves];\\n\\n  // Build the Merkle tree\\n  while (layers[layers.length - 1].length > 1) {\\n    const currentLayer = layers[layers.length - 1];\\n    const nextLayer = [];\\n\\n    for (let i = 0; i < currentLayer.length; i += 2) {\\n      const left = currentLayer[i];\\n      const right = currentLayer[i + 1] ? currentLayer[i + 1] : left; // Handle odd number of nodes\\n      nextLayer.push(await poseidonContract.methods.poseidon([left,right]).call())\\n    }\\n    layers.push(nextLayer);\\n  }\\n\\n  const root = layers[layers.length - 1][0];\\n\\n  function getPath(leafIndex) {\\n    let pathElements = [];\\n    let pathIndices = [];\\n    let currentIndex = leafIndex;\\n\\n    for (let i = 0; i < layers.length - 1; i++) {\\n      const currentLayer = layers[i];\\n      const isLeftNode = currentIndex % 2 === 0;\\n      const siblingIndex = isLeftNode ? currentIndex + 1 : currentIndex - 1;\\n\\n      pathIndices.push(isLeftNode ? 0 : 1);\\n      pathElements.push(siblingIndex < currentLayer.length ? currentLayer[siblingIndex] : currentLayer[currentIndex]);\\n\\n      currentIndex = Math.floor(currentIndex / 2);\\n    }\\n\\n    return {\\n      PathElements: pathElements,\\n      PathIndices: pathIndices\\n    };\\n  }\\n\\n  // You can get the path for any leaf index by calling getPath(leafIndex)\\n  return {\\n    getMerklePathForLeaf: getPath,\\n    root: root\\n  };\\n}\\n\\nfunction addressToUint(address) {\\n  const hexString = address.replace(/^0x/, '');\\n  const uint = BigInt('0x' + hexString);\\n  return uint;\\n}\\n\\nasync function getWithdrawalProof(index, privateKey, nullifier, recipient, root) {\\n  let merklePath = await getMerklePath(leaves)\\n  let pathElements = merklePath.getMerklePathForLeaf(index).PathElements;\\n  let pathIndices = merklePath.getMerklePathForLeaf(index).PathIndices;\\n  let proverParams = {\\n    \\\"privateKey\\\": privateKey,\\n    \\\"nullifier\\\": nullifier,\\n    \\\"recipient\\\": addressToUint(recipient),\\n    \\\"root\\\": root,\\n    \\\"pathElements\\\": pathElements,\\n    \\\"pathIndices\\\": pathIndices\\n  }\\n\\n  const { proof, publicSignals } = await snarkjs.groth16.fullProve( \\n    proverParams, \\n    \\\"../zk_artifacts/proveWithdrawal.wasm\\\", \\\"../zk_artifacts/proveWithdrawal_final.zkey\\\"\\n  );\\n\\n  let pA = proof.pi_a\\n  pA.pop()\\n  let pB = proof.pi_b\\n  pB.pop()\\n  let pC = proof.pi_c\\n  pC.pop()\\n\\n  document.getElementById(\\\"web3_message\\\").textContent=\\\"Proof generated please confirm transaction.\\\";\\n\\n  return {\\n    pA: pA,\\n    pB: pB,\\n    pC: pC,\\n    publicSignals: publicSignals\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"5. The Relayer\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Generating ZK anonymity proofs makes no sense if we end up posting the transaction ourselves. Doing so would compromise privacy, as everything on Ethereum is public. This is why we need a relayer, an intermediary that executes the transaction on-chain on behalf of the anonymous user.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's start by creating the backend file.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"relayer.mjs\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"import fs from \\\"fs\\\"\\nimport cors from \\\"cors\\\"\\nimport express from \\\"express\\\"\\nimport { ethers } from 'ethers';\\n\\nconst app = express()\\napp.use(cors())\\n\\nconst JSON_CONTRACT_PATH = \\\"./json_abi/Huracan.json\\\"\\nconst CHAIN_ID = \\\"534351\\\"\\nconst PORT = 8080\\nvar contract\\nvar provider\\nvar signer\\n\\nconst { RPC_URL, HURACAN_ADDRESS, RELAYER_PRIVATE_KEY, RELAYER_ADDRESS } = process.env;\\n\\nconst loadContract = async (data) => {\\n  data = JSON.parse(data);\\n  contract = new ethers.Contract(HURACAN_ADDRESS, data, signer);\\n}\\n\\nasync function initAPI() {\\n  provider = new ethers.JsonRpcProvider(RPC_URL);\\n  signer = new ethers.Wallet(RELAYER_PRIVATE_KEY, provider);\\n\\n  fs.readFile(JSON_CONTRACT_PATH, 'utf8', function (err,data) {\\n    if (err) {\\n      return console.log(err);\\n    }\\n    loadContract(data)\\n  });\\n\\n  app.listen(PORT, () => {\\n    console.log(\\\\`Listening to port \\\\${PORT}\\\\`)\\n  })\\n}\\n\\nasync function relayMessage(pA, pB, pC, publicSignals)\\n{\\n  console.log(pA)\\n  console.log(pB)\\n  console.log(pC)\\n  console.log(publicSignals)\\n  const transaction = {\\n    from: RELAYER_ADDRESS,\\n    to: HURACAN_ADDRESS,\\n    value: '0',\\n    gasPrice: \\\"700000000\\\", // 0.7 gwei\\n    nonce: await provider.getTransactionCount(RELAYER_ADDRESS),\\n    chainId: CHAIN_ID,\\n    data: contract.interface.encodeFunctionData(\\n      \\\"withdraw\\\",[pA, pB, pC, publicSignals]\\n    )\\n  };\\n  const signedTransaction = await signer.populateTransaction(transaction);\\n  const transactionResponse = await signer.sendTransaction(signedTransaction);\\n  console.log('🎉 The hash of your transaction is:', transactionResponse.hash);\\n}\\n\\napp.get('/relay', (req, res) => {\\n  console.log(req)\\n  var pA = req.query[\\\"pA\\\"].split(',')\\n  var pBTemp = req.query[\\\"pB\\\"].split(',')\\n  const pB = [\\n    [pBTemp[0], pBTemp[1]],\\n    [pBTemp[2], pBTemp[3]]\\n  ];\\n  var pC = req.query[\\\"pC\\\"].split(',')\\n  var publicSignals = req.query[\\\"publicSignals\\\"].split(',')\\n\\n  relayMessage(pA, pB, pC, publicSignals)\\n\\n  res.setHeader('Content-Type', 'application/json');\\n  res.send({\\n    \\\"message\\\": \\\"the proof was relayed\\\"\\n  })\\n})\\n\\ninitAPI()\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Install the \", _jsx(_components.code, {\n        children: \"coors\"\n      }), \" library to run the relayer locally.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"npm install cors express ethers\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now deploy the server by replacing \", _jsx(_components.code, {\n        children: \"TUURLRPC\"\n      }), \", \", _jsx(_components.code, {\n        children: \"TUHURACANADDRESS\"\n      }), \", \", _jsx(_components.code, {\n        children: \"TULLAVEPRIVADA\"\n      }), \", \", _jsx(_components.code, {\n        children: \"TUADDRESS\"\n      }), \" in the following command.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"RPC_URL=TUURLRPC HURACAN_ADDRESS=TUHURACANADDRESS RELAYER_PRIVATE_KEY=TULLAVEPRIVADA RELAYER_ADDRESS=TUADDRESS node relayer.mjs\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You are ready to deposit and withdraw funds on Huracan from the web interface.\"\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m0gfsc81pgjfcyt32gyu.png\",\n        alt: \"Huracan web\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Once everything is ready this is how your app should look like\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"6. How to Take Huracan to Production?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"a. Store Historical Roots On-Chain\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By only storing the most recent root, the generated proof must use this root. This means that if someone deposits right after generating a withdrawal proof, and thus modifies the root, the proof will become invalid, and a new one will need to be generated.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Necessary Changes:\"\n      }), \" Store the entire historical record of roots on-chain, for example, using a mapping like \", _jsx(_components.code, {\n        children: \"mapping(uint id => uint root) public roots;\"\n      }), \" and use the most recent root when generating a proof. If someone makes a deposit and changes the root, there will be no problem as the verification will be done against any historically saved root using a function like \", _jsx(_components.code, {\n        children: \"isKnownRoot(uint root)\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"b. Index the Merkle Tree in an Accessible Place\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To generate an inclusion proof, we need to read the current state of the tree. Currently, we read it from the \", _jsx(_components.code, {\n        children: \"commitments\"\n      }), \" variable, but this process is slow and requires many RPC calls if the tree size is large.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Necessary Changes:\"\n      }), \" Store and index the entire tree in an accessible location. An ideal place for this might be a subgraph.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"c. Incentivize the Relayer\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It’s necessary to offer a reward to the relayer, as they cover the on-chain transaction fees.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Necessary Changes:\"\n      }), \" When generating the proof, allocate a percentage of the note to the relayer. You can do this by adding an extra parameter in the circuits, like \", _jsx(_components.code, {\n        children: \"signal input fee;\"\n      }), \", and in Solidity, send this value to \", _jsx(_components.code, {\n        children: \"msg.sender\"\n      }), \" or to the address determined by the relayer.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"d. Use Appropriate Libraries\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the web app, instead of vanilla HTML and JS, you should use a frontend framework like React, Angular, or Vue to provide a better experience for users and developers.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For the relayer, instead of Express, use a more robust backend and host it on a machine equipped to handle a high number of transactions with anti-DoS mechanisms and a suitable firewall, as the relayer’s funds used for gas are a target for hacking.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"e. Define the Size of the Merkle Tree\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This example works for 4 depositors; you’ll need to reflect changes in the circuit and contract to accommodate a larger tree.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Necessary Changes:\"\n      }), \" Start by changing \", _jsx(_components.a, {\n        href: \"https://github.com/Turupawn/Huracan/blob/master/circuits/proveWithdrawal.circom#L67\",\n        children: \"the number of levels in the circuit\"\n      }), \"; it is currently set to 2, which is enough for a tree with 4 leaves. Also, update the constants \", _jsx(_components.code, {\n        children: \"LEVELS\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"MAX_SIZE\"\n      }), \" \", _jsx(_components.a, {\n        href: \"https://github.com/Turupawn/Huracan/blob/master/contracts/Huracan.sol#L16\",\n        children: \"in the contract\"\n      }), \". If your tree is very large, you can save gas on deployment by hardcoding the default values for an empty tree \", _jsx(_components.a, {\n        href: \"https://github.com/Turupawn/Huracan/blob/master/contracts/Huracan.sol#L33\",\n        children: \"instead of using a loop\"\n      }), \" as shown.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"f. Remember, Everything We Used Is in Experimental Stages\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The circuits and contracts in this guide are not properly audited, as are the libraries used. For example, Poseidon is a new hashing function that is promising and used instead of the traditional Pedersen.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Also, remember, this tutorial does not cover a secure trusted setup. It is recommended to conduct an open ceremony with sufficient time for participation.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"7. Ideas for Further Exploration\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"a. Exclusion Proofs\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Just as we handle inclusion proofs in this example, we can create exclusion proofs that \", _jsx(_components.em, {\n        children: \"demonstrate that we are not part of a blacklisted group\"\n      }), \". This could help in complying with future regulations that determine states.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"b. Use ERC20s Instead of Ether\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Instead of using Ether as the native currency in Solidity, you can use a specific ERC20 token. The changes would only be in the Solidity contracts and web app, while the circuits could remain the same.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"c. Experiment with Re-Staking\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once you integrate ERC20s, a good next step might be to experiment with generating passive income using LSTs (Liquid Staking Tokens).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"d. Think of Other Use Cases!\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Anonymous inclusion proofs have many use cases, even beyond DeFi. Think about how you can apply what you’ve learned to voting systems, governance, social networks, video games, etc.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "0x-on-scroll",
    "name": "How to fetch live swap prices with 0x Swap API on Scroll",
    "index": 7,
    "summary": "Learn how to embed crypto trading into your app using 0x Swap API",
    "author": "Jessica Lin",
    "authorIcon": "https://avatars.githubusercontent.com/u/8042156?v=4",
    "authorLink": "https://x.com/hey_its_jlin",
    "published": "Sep 18, 2024",
    "readTime": "15 min read",
    "labels": [
      "DeFi"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    em: \"em\",\n    a: \"a\",\n    strong: \"strong\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    ol: \"ol\",\n    h3: \"h3\",\n    code: \"code\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.em, {\n        children: \"Learn how to use the 0x Swap API to fetch live swap prices and seamlessly integrate crypto trading into your app.\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Ever wondered how your favorite token trading dapp finds the best price when you make a swap? It’s likely using a \", _jsx(_components.a, {\n        href: \"https://0x.org/post/managed-liquidity\",\n        children: \"liquidity aggregator\"\n      }), \", which sources prices from both offchain (e.g., Market Makers, RFQ) and onchain (e.g., DEXs, AMMs) sources to find the best deal.\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"/images/contents/matcha.png\",\n        alt: \"matcha screenshot\",\n        width: \"300\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Figure 1: Matcha.xyz trading app\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this tutorial, we'll explore how the \", _jsx(_components.a, {\n        href: \"https://0x.org/docs/0x-swap-api/introduction\",\n        children: \"0x Swap API\"\n      }), \" fetches live quotes using \", _jsx(_components.a, {\n        href: \"https://0x.org/post/0x-smart-order-routing\",\n        children: \"smart order routing\"\n      }), \". This process routes transactions across decentralized exchanges, aiming for \", _jsx(_components.strong, {\n        children: \"the best price\"\n      }), \" and \", _jsx(_components.strong, {\n        children: \"minimal transaction costs\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"/images/contents/order-route.png\",\n        alt: \"order route screenshot\",\n        width: \"650\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Figure 1: 0x routes to find the best liquidity sources for a swap through both\\nonchain and offchain sources.\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The 0x Swap API powers swaps in major wallets and exchanges like Coinbase Wallet, Robinhood Wallet, Matcha, Metamask, Zerion, Zapper, and more. With over 71 million transactions and $148B+ in volume from 8 million users, 0x APIs are trusted by many top trading apps.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Best of all, no smart contract development is needed. The 0x API allows web developers to easily leverage the 0x Settler smart contracts, which handle all trade settlement logic, so you can focus on delivering the best user experience.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Why Use the 0x Swap API?\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"⛓️ \", _jsx(_components.strong, {\n          children: \"Multi-chain liquidity\"\n        }), \": Easily access liquidity across popular networks (see the full list of supported networks).\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"🤑 \", _jsx(_components.strong, {\n          children: \"Monetize your app\"\n        }), \": Earn revenue through seamless swap integration.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"🛡️ \", _jsx(_components.strong, {\n          children: \"User protection\"\n        }), \": Our smart contracts eliminate allowance risk with innovations like Permit2, ensuring secure token approvals.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"↩ \", _jsx(_components.strong, {\n          children: \"Best execution\"\n        }), \": Minimize transaction reverts for smoother swaps.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"💰 \", _jsx(_components.strong, {\n          children: \"Exclusive RFQ liquidity\"\n        }), \": Competitive with AMMs, offering zero slippage and guaranteed MEV protection.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"🚀 \", _jsx(_components.strong, {\n          children: \"User-friendly\"\n        }), \": Quick and easy to integrate!\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Pre-requisites\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This tutorial assumes some familiarity with the following,\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"making API calls\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"JavaScript/TypeScript\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://viem.sh/\",\n          children: \"viem\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"How to Swap Tokens in 6 Steps\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"0\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Get a 0x API key\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Get an indicative price\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"(If needed) Set token allowance\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Fetch a firm quote\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Sign the Permit2 EIP-712 message\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Append signature length and signature data to calldata\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Submit the transaction with Permit2 signature\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Tip\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"⚡️ See these steps in action in the \", _jsx(_components.a, {\n        href: \"https://github.com/0xProject/0x-examples/tree/main/swap-v2-headless-example\",\n        children: \"Swap headless example\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"0. Get a 0x API key\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To use the 0x Swap API, you'll need an API key for authentication. Follow these steps:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://dashboard.0x.org/\",\n          children: \"Sign up for a 0x account\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Once registered, generate your live API key from the dashboard.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For detailed instructions, refer to the \", _jsx(_components.a, {\n        href: \"https://0x.org/docs/introduction/getting-started\",\n        children: \"Getting Started Guide\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. Get an Indicative Price\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's find the best price to swap 100 WETH for wstETH on Scroll!\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To find the best price for a token swap, use the \", _jsx(_components.a, {\n        href: \"https://0x.org/docs/api#tag/Swap/operation/swap::permit2::getPrice\",\n        children: _jsx(_components.code, {\n          children: \"/swap/permit2/price\"\n        })\n      }), \" endpoint. This gives you an indicative price for an asset pair without committing to a transaction. Think of it as \\\"browsing\\\" for prices.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Unlike \", _jsx(_components.code, {\n        children: \"/quote\"\n      }), \", which we'll use later to create an actual order, \", _jsx(_components.code, {\n        children: \"/price\"\n      }), \" is a read-only endpoint, perfect for getting a rough idea of the potential swap rate.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Example Request\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here’s an example of a \", _jsx(_components.code, {\n        children: \"/price\"\n      }), \" request to sell 100 WETH for wstETH on Scroll. You can view the full code \", _jsx(_components.a, {\n        href: \"https://github.com/0xProject/0x-examples/blob/main/swap-v2-headless-example/index.ts#L60-L77\",\n        children: \"here\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"const priceParams = new URLSearchParams({\\n  chainId: \\\"534352\\\", // Scroll chainId. Refer to the 0x Cheat Sheet for supported endpoints: https://0x.org/docs/introduction/0x-cheat-sheet\\n  sellToken: \\\"0x5300000000000000000000000000000000000004\\\", // WETH\\n  buyToken: \\\"0xf610A9dfB7C89644979b4A0f27063E9e7d7Cda32\\\", // wstETH\\n  sellAmount: \\\"100000000000000000000\\\", // WETH uses 18 decimals, so `sellAmount` is 100 * 10^18\\n  taker: \\\"$USER_TAKER_ADDRESS\\\", // Address of the user making the trade\\n});\\n\\nconst headers = {\\n  \\\"0x-api-key\\\": \\\"[api-key]\\\", // Get your live API key from the 0x Dashboard: https://dashboard.0x.org/apps\\n  \\\"0x-version\\\": \\\"v2\\\",\\n};\\n\\nconst priceResponse = await fetch(\\n  \\\"https://api.0x.org/swap/permit2/price?\\\" + priceParams.toString(),\\n  { headers },\\n);\\n\\nconsole.log(await priceResponse.json());\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Example response\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The response from the \", _jsx(_components.code, {\n        children: \"/price\"\n      }), \" endpoint will look like the example below. Key parameters include:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"buyAmount\"\n        }), \": The amount of \", _jsx(_components.code, {\n          children: \"buyToken\"\n        }), \" (in \", _jsx(_components.code, {\n          children: \"buyToken\"\n        }), \" units) that will be received from the swap.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"issues\"\n        }), \": An object detailing any potential problems identified during 0x validation, which could prevent the swap from being successfully executed.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"route\"\n        }), \": The path of liquidity sources used to execute the swap.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For a complete list of response fields, see the \", _jsx(_components.a, {\n        href: \"https://0x.org/docs/api#tag/Swap/operation/swap::permit2::getPrice\",\n        children: \"API references\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(\"details\", {\n      children: [_jsx(\"summary\", {\n        children: \"Expand to see the full response\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"blockNumber\\\": \\\"9382122\\\",\\n  \\\"buyAmount\\\": \\\"84721170258179911287\\\",\\n  \\\"buyToken\\\": \\\"0xf610a9dfb7c89644979b4a0f27063e9e7d7cda32\\\",\\n  \\\"fees\\\": {\\n    \\\"integratorFee\\\": null,\\n    \\\"zeroExFee\\\": {\\n      \\\"amount\\\": \\\"127272664383845646\\\",\\n      \\\"token\\\": \\\"0xf610a9dfb7c89644979b4a0f27063e9e7d7cda32\\\",\\n      \\\"type\\\": \\\"volume\\\"\\n    },\\n    \\\"gasFee\\\": null\\n  },\\n  \\\"gas\\\": \\\"401014\\\",\\n  \\\"gasPrice\\\": \\\"85358949\\\",\\n  \\\"issues\\\": {\\n    \\\"allowance\\\": {\\n      \\\"actual\\\": \\\"0\\\",\\n      \\\"spender\\\": \\\"0x000000000022d473030f116ddee9f6b43ac78ba3\\\"\\n    },\\n    \\\"balance\\\": {\\n      \\\"token\\\": \\\"0x5300000000000000000000000000000000000004\\\",\\n      \\\"actual\\\": \\\"0\\\",\\n      \\\"expected\\\": \\\"100000000000000000000\\\"\\n    },\\n    \\\"simulationIncomplete\\\": false,\\n    \\\"invalidSourcesPassed\\\": []\\n  },\\n  \\\"liquidityAvailable\\\": true,\\n  \\\"minBuyAmount\\\": \\\"83873958555598110900\\\",\\n  \\\"route\\\": {\\n    \\\"fills\\\": [\\n      {\\n        \\\"from\\\": \\\"0x5300000000000000000000000000000000000004\\\",\\n        \\\"to\\\": \\\"0xf610a9dfb7c89644979b4a0f27063e9e7d7cda32\\\",\\n        \\\"source\\\": \\\"Nuri_CL\\\",\\n        \\\"proportionBps\\\": \\\"10000\\\"\\n      }\\n    ],\\n    \\\"tokens\\\": [\\n      {\\n        \\\"address\\\": \\\"0x5300000000000000000000000000000000000004\\\",\\n        \\\"symbol\\\": \\\"WETH\\\"\\n      },\\n      {\\n        \\\"address\\\": \\\"0xf610a9dfb7c89644979b4a0f27063e9e7d7cda32\\\",\\n        \\\"symbol\\\": \\\"wstETH\\\"\\n      }\\n    ]\\n  },\\n  \\\"sellAmount\\\": \\\"100000000000000000000\\\",\\n  \\\"sellToken\\\": \\\"0x5300000000000000000000000000000000000004\\\",\\n  \\\"tokenMetadata\\\": {\\n    \\\"buyToken\\\": {\\n      \\\"buyTaxBps\\\": \\\"0\\\",\\n      \\\"sellTaxBps\\\": \\\"0\\\"\\n    },\\n    \\\"sellToken\\\": {\\n      \\\"buyTaxBps\\\": \\\"0\\\",\\n      \\\"sellTaxBps\\\": \\\"0\\\"\\n    }\\n  },\\n  \\\"totalNetworkFee\\\": \\\"35525885088398\\\",\\n  \\\"zid\\\": \\\"0x55b4949012d122a44a30f4c0\\\"\\n}\\n\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Set a Token Allowance\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Before proceeding with the swap, you'll need to set a token allowance. A \", _jsx(_components.a, {\n        href: \"https://tokenallowance.io/\",\n        children: \"token allowance\"\n      }), \" authorizes a third party to move a specific amount of your tokens. In this case, you are permitting the \", _jsx(_components.a, {\n        href: \"https://github.com/Uniswap/permit2\",\n        children: \"Permit2 contract\"\n      }), \" to trade your ERC20 tokens on your behalf. (Curious about Permit2? Read more about it \", _jsx(_components.a, {\n        href: \"https://0x.org/docs/developer-resources/faqs-and-troubleshooting#parameter-questions\",\n        children: \"here\"\n      }), \".)\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To allow this, you must approve an allowance, specifying the amount of ERC20 tokens the contract can move. For more details on how to set token allowances, see \", _jsx(_components.a, {\n        href: \"/0x-swap-api/advanced-topics/how-to-set-your-token-allowances\",\n        children: \"How to set your token allowances\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Tip\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Ensure the token allowance covers both the buy/sell amount and gas fees. Failing to do so may result in a 'Gas estimation failed' error.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Example Code\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Below is an example of checking and setting token approvals using viem's \", _jsx(_components.a, {\n        href: \"https://viem.sh/docs/contract/getContract.html\",\n        children: _jsx(_components.code, {\n          children: \"getContract\"\n        })\n      }), \" function.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { getContract } from 'viem';\\n...\\n// Initialize contracts. Note: abi and client setup not shown in this snippet.\\nconst Permit2 = getContract({\\n    address: '0x000000000022D473030F116dDEE9F6B43aC78BA3', // Permit2 contract address\\n    abi: exchangeProxyAbi,\\n    client,\\n});\\nconst usdc = getContract({\\n    address: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913', // USDC token address\\n    abi: erc20Abi,\\n    client,\\n});\\n\\n// Check if the allowance is sufficient for Permit2 to spend the sellToken.\\nif (sellAmount > (await usdc.read.allowance([client.account.address, Permit2.address]))) {\\n    try {\\n        const { request } = await usdc.simulate.approve([Permit2.address, maxUint256]);\\n        console.log('Approving Permit2 to spend USDC...', request);\\n        // Write the approval if necessary.\\n        const hash = await usdc.write.approve(request.args);\\n        console.log('Approved Permit2 to spend USDC.', await client.waitForTransactionReceipt({ hash }));\\n    } catch (error) {\\n        console.log('Error approving Permit2:', error);\\n    }\\n} else {\\n    console.log('USDC is already approved for Permit2');\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. Fetch a Firm Quote\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Once you've found a good price and you're ready to execute a trade, use the \", _jsx(_components.a, {\n        href: \"https://0x.org/docs/api#tag/Swap/operation/swap::permit2::getQuote\",\n        children: _jsx(_components.code, {\n          children: \"/swap/permit2/quote\"\n        })\n      }), \" endpoint to request a firm quote. Unlike the indicative \", _jsx(_components.code, {\n        children: \"/price\"\n      }), \" endpoint, this represents a soft commitment to filling the suggested orders, with potential consequences for failing to fulfill.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"/swap/permit2/quote\"\n      }), \" response contains a full 0x order that can be submitted to an Ethereum node. The Market Maker will have reserved the necessary assets, which significantly reduces the chances of the order failing.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Caution\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Only use \", _jsx(_components.code, {\n        children: \"/quote\"\n      }), \" when you're prepared to fill the order. Excessive unfilled requests may result in a ban, as Market Makers allocate assets based on these requests. If you're browsing for prices, use \", _jsx(_components.code, {\n        children: \"/price\"\n      }), \" instead.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Example Request\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here’s an example of fetching a firm quote to sell 100 WETH for wstETH using the \", _jsx(_components.code, {\n        children: \"/quote\"\n      }), \" endpoint (note its similarity to the \", _jsx(_components.code, {\n        children: \"/price\"\n      }), \" request):\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"const qs = require(\\\"qs\\\");\\n\\nconst params = {\\n  chainId: \\\"534352\\\", // Scroll. Refer to the 0x Cheat Sheet for all supported endpoints: https://0x.org/docs/introduction/0x-cheat-sheet\\n  sellToken: \\\"0x5300000000000000000000000000000000000004\\\", // WETH\\n  buyToken: \\\"0xf610A9dfB7C89644979b4A0f27063E9e7d7Cda32\\\", // wstETH\\n  sellAmount: \\\"100000000000000000000\\\", // WETH uses 18 decimal places, so the sell amount is `100 * 10^18`.\\n  taker: \\\"$USER_TAKER_ADDRESS\\\", // The address that will execute the trade.\\n};\\n\\nconst headers = { \\\"0x-api-key\\\": \\\"[api-key]\\\", \\\"0x-version\\\": \\\"v2\\\" }; // Obtain your API key from the 0x Dashboard: https://dashboard.0x.org/apps\\n\\nconst response = await fetch(\\n  `https://api.0x.org/swap/permit2/quote?${qs.stringify(params)}`,\\n  { headers },\\n);\\n\\nconsole.log(await response.json());\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Example Response\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Many of the fields in the \", _jsx(_components.code, {\n        children: \"/quote\"\n      }), \" response are similar to those in the \", _jsx(_components.code, {\n        children: \"/price\"\n      }), \" response, but there are additional fields required to submit the quote to the blockchain. Key response parameters include:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"transaction\"\n        }), \" - Contains the details needed to submit the transaction to the blockchain.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"permit2\"\n        }), \" - An approval object with fields necessary for submitting approval for this transaction. It will be \", _jsx(_components.code, {\n          children: \"null\"\n        }), \" if the sell token is native or if the transaction involves wrapping/unwrapping a native token.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"route\"\n        }), \" - The liquidity sources used to execute this swap.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"tokenMetadata\"\n        }), \" - Metadata for the buy and sell tokens in the swap, including any buy/sell tax that the tokens may incur.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"See a \", _jsx(_components.a, {\n        href: \"https://0x.org/docs/api#tag/Swap/operation/swap::permit2::getQuote\",\n        children: \"full list of API responses\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(\"details\", {\n      children: [_jsx(\"summary\", {\n        children: \"Expand to see response\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-json\",\n          children: \"{\\n  \\\"blockNumber\\\": \\\"9382392\\\",\\n  \\\"buyAmount\\\": \\\"84721170406314741663\\\",\\n  \\\"buyToken\\\": \\\"0xf610a9dfb7c89644979b4a0f27063e9e7d7cda32\\\",\\n  \\\"fees\\\": {\\n    \\\"integratorFee\\\": null,\\n    \\\"zeroExFee\\\": {\\n      \\\"amount\\\": \\\"127272664606381695\\\",\\n      \\\"token\\\": \\\"0xf610a9dfb7c89644979b4a0f27063e9e7d7cda32\\\",\\n      \\\"type\\\": \\\"volume\\\"\\n    },\\n    \\\"gasFee\\\": null\\n  },\\n  \\\"issues\\\": {\\n    \\\"allowance\\\": {\\n      \\\"actual\\\": \\\"0\\\",\\n      \\\"spender\\\": \\\"0x000000000022d473030f116ddee9f6b43ac78ba3\\\"\\n    },\\n    \\\"balance\\\": {\\n      \\\"token\\\": \\\"0x5300000000000000000000000000000000000004\\\",\\n      \\\"actual\\\": \\\"0\\\",\\n      \\\"expected\\\": \\\"100000000000000000000\\\"\\n    },\\n    \\\"simulationIncomplete\\\": false,\\n    \\\"invalidSourcesPassed\\\": []\\n  },\\n  \\\"liquidityAvailable\\\": true,\\n  \\\"minBuyAmount\\\": \\\"83873958702251592600\\\",\\n  \\\"permit2\\\": {\\n    \\\"type\\\": \\\"Permit2\\\",\\n    \\\"hash\\\": \\\"0x65ee5b15bd345194a150d71b25f026d4c35552af2a1ab5a4941d1b6fe8a2ebe0\\\",\\n    \\\"eip712\\\": {\\n      \\\"types\\\": {\\n        \\\"TokenPermissions\\\": [\\n          {\\n            \\\"name\\\": \\\"token\\\",\\n            \\\"type\\\": \\\"address\\\"\\n          },\\n          {\\n            \\\"name\\\": \\\"amount\\\",\\n            \\\"type\\\": \\\"uint256\\\"\\n          }\\n        ],\\n        \\\"EIP712Domain\\\": [\\n          {\\n            \\\"name\\\": \\\"name\\\",\\n            \\\"type\\\": \\\"string\\\"\\n          },\\n          {\\n            \\\"name\\\": \\\"chainId\\\",\\n            \\\"type\\\": \\\"uint256\\\"\\n          },\\n          {\\n            \\\"name\\\": \\\"verifyingContract\\\",\\n            \\\"type\\\": \\\"address\\\"\\n          }\\n        ],\\n        \\\"PermitTransferFrom\\\": [\\n          {\\n            \\\"name\\\": \\\"permitted\\\",\\n            \\\"type\\\": \\\"TokenPermissions\\\"\\n          },\\n          {\\n            \\\"name\\\": \\\"spender\\\",\\n            \\\"type\\\": \\\"address\\\"\\n          },\\n          {\\n            \\\"name\\\": \\\"nonce\\\",\\n            \\\"type\\\": \\\"uint256\\\"\\n          },\\n          {\\n            \\\"name\\\": \\\"deadline\\\",\\n            \\\"type\\\": \\\"uint256\\\"\\n          }\\n        ]\\n      },\\n      \\\"domain\\\": {\\n        \\\"name\\\": \\\"Permit2\\\",\\n        \\\"chainId\\\": 534352,\\n        \\\"verifyingContract\\\": \\\"0x000000000022d473030f116ddee9f6b43ac78ba3\\\"\\n      },\\n      \\\"message\\\": {\\n        \\\"permitted\\\": {\\n          \\\"token\\\": \\\"0x5300000000000000000000000000000000000004\\\",\\n          \\\"amount\\\": \\\"100000000000000000000\\\"\\n        },\\n        \\\"spender\\\": \\\"0x6c403dba21f072e16b7de2b013f8adeae9c2e76e\\\",\\n        \\\"nonce\\\": \\\"2241959297937691820908574931991560\\\",\\n        \\\"deadline\\\": \\\"1726615654\\\"\\n      },\\n      \\\"primaryType\\\": \\\"PermitTransferFrom\\\"\\n    }\\n  },\\n  \\\"route\\\": {\\n    \\\"fills\\\": [\\n      {\\n        \\\"from\\\": \\\"0x5300000000000000000000000000000000000004\\\",\\n        \\\"to\\\": \\\"0xf610a9dfb7c89644979b4a0f27063e9e7d7cda32\\\",\\n        \\\"source\\\": \\\"Nuri_CL\\\",\\n        \\\"proportionBps\\\": \\\"10000\\\"\\n      }\\n    ],\\n    \\\"tokens\\\": [\\n      {\\n        \\\"address\\\": \\\"0x5300000000000000000000000000000000000004\\\",\\n        \\\"symbol\\\": \\\"WETH\\\"\\n      },\\n      {\\n        \\\"address\\\": \\\"0xf610a9dfb7c89644979b4a0f27063e9e7d7cda32\\\",\\n        \\\"symbol\\\": \\\"wstETH\\\"\\n      }\\n    ]\\n  },\\n  \\\"sellAmount\\\": \\\"100000000000000000000\\\",\\n  \\\"sellToken\\\": \\\"0x5300000000000000000000000000000000000004\\\",\\n  \\\"tokenMetadata\\\": {\\n    \\\"buyToken\\\": {\\n      \\\"buyTaxBps\\\": \\\"0\\\",\\n      \\\"sellTaxBps\\\": \\\"0\\\"\\n    },\\n    \\\"sellToken\\\": {\\n      \\\"buyTaxBps\\\": \\\"0\\\",\\n      \\\"sellTaxBps\\\": \\\"0\\\"\\n    }\\n  },\\n  \\\"totalNetworkFee\\\": \\\"35867824219906\\\",\\n  \\\"transaction\\\": {\\n    \\\"to\\\": \\\"0x6c403dba21f072e16b7de2b013f8adeae9c2e76e\\\",\\n    \\\"data\\\": \\\"0x1fff991f0000000000000000000000004d2a422db44144996e855ce15fb581a477dbb947000000000000000000000000f610a9dfb7c89644979b4a0f27063e9e7d7cda320000000000000000000000000000000000000000000000048bfc290e717d4b9800000000000000000000000000000000000000000000000000000000000000a0baa017bd677047464e1a54e4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000020438c9c14700000000000000000000000053000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000002710000000000000000000000000aaae99091fbb28d400029052821653c1c752483b000000000000000000000000000000000000000000000000000000000000008400000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000124c04b8d59000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000006c403dba21f072e16b7de2b013f8adeae9c2e76e0000000000000000000000000000000000000000000000000000000066ea106600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b53000000000000000000000000000000000000040000faf610a9dfb7c89644979b4a0f27063e9e7d7cda320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012438c9c147000000000000000000000000f610a9dfb7c89644979b4a0f27063e9e7d7cda32000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000f610a9dfb7c89644979b4a0f27063e9e7d7cda32000000000000000000000000000000000000000000000000000000000000002400000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000ad01c20d5886137e056775af56915de824c8fce500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffc1fb425e0000000000000000000000006c403dba21f072e16b7de2b013f8adeae9c2e76e00000000000000000000000053000000000000000000000000000000000000040000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000006e898131631616b1779bad70bc080000000000000000000000000000000000000000000000000000000066ea106600000000000000000000000000000000000000000000000000000000000000c0\\\",\\n    \\\"gas\\\": \\\"401014\\\",\\n    \\\"gasPrice\\\": \\\"86506305\\\",\\n    \\\"value\\\": \\\"0\\\"\\n  },\\n  \\\"zid\\\": \\\"0xbaa017bd677047464e1a54e4\\\"\\n}\\n\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. Sign the Permit2 EIP-712 message\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now that we have our quote, the next step is to sign and append the necessary data before submitting the order to the blockchain.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, sign the \", _jsx(_components.code, {\n        children: \"permit2.eip712\"\n      }), \" object that we received from the quote response.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"// Sign permit2.eip712 returned from quote\\nlet signature: Hex;\\nsignature = await signTypedData(quote.permit2.eip712);\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"5. Append Signature Length and Data to \", _jsx(_components.code, {\n        children: \"transaction.data\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Next, append the signature length and signature data to \", _jsx(_components.code, {\n        children: \"transaction.data\"\n      }), \". The format should be \", _jsx(_components.code, {\n        children: \"<sig len><sig data>\"\n      }), \", where:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"<sig len>\"\n        }), \": 32-byte unsigned big-endian integer representing the length of the signature\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"<sig data>\"\n        }), \": The actual signature data\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"import { concat, numberToHex, size } from \\\"viem\\\";\\n\\nif (permit2?.eip712) {\\n  const signature = await signTypedDataAsync(permit2.eip712);\\n  const signatureLengthInHex = numberToHex(size(signature), {\\n    signed: false,\\n    size: 32,\\n  });\\n  transaction.data = concat([\\n    transaction.data,\\n    signatureLengthInHex,\\n    signature,\\n  ]);\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"6. Submit the Transaction with the Permit2 Signature\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The final step is to submit the transaction with all required parameters using your preferred web3 library (e.g., \", _jsx(_components.code, {\n        children: \"wagmi\"\n      }), \", \", _jsx(_components.code, {\n        children: \"viem\"\n      }), \", \", _jsx(_components.code, {\n        children: \"ethers.js\"\n      }), \", \", _jsx(_components.code, {\n        children: \"web3.js\"\n      }), \"). In this example, we use wagmi's \", _jsx(_components.a, {\n        href: \"https://wagmi.sh/react/api/hooks/useSendTransaction\",\n        children: _jsx(_components.code, {\n          children: \"useSendTransaction\"\n        })\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"sendTransaction({\\n    account: walletClient?.account.address,\\n    gas: quote?.transaction.gas ? BigInt(quote.transaction.gas) : undefined,\\n    to: quote?.transaction.to,\\n    data: quote?.transaction.data.replace(\\n        MAGIC_CALLDATA_STRING,\\n        signature.slice(2)\\n    ) as Hex,\\n    chainId: chainId,\\n});\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can also check your transaction on \", _jsx(_components.a, {\n        href: \"https://scrollscan.com/address/0x6c403dba21f072e16b7de2b013f8adeae9c2e76e\",\n        children: \"Scrollscan\"\n      }), \" (trades are settled by the \", _jsx(_components.a, {\n        href: \"https://0x.org/docs/introduction/0x-cheat-sheet#finding-addreses-for-0x-settler-contracts\",\n        children: \"0x Settler smart contract\"\n      }), \")!\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Wrap-Up\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Congratulations! You've successfully requested a live swap quote and executed a swap on Scroll using the 0x Swap API.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Check out these starter projects to dive deeper:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/0xProject/0x-examples/tree/main/swap-v2-headless-example\",\n          children: \"(Code) Swap API Headless Example\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/0xProject/0x-examples/tree/main/swap-v2-next-app\",\n          children: \"(Code) Next.js 0x Demo App\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/0xProject/0x-examples\",\n          children: \"(Code) Examples Repo\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"./build-token-swap-dapp-nextjs\",\n          children: \"(Guide) Build a Next.js dApp with 0x Swap API\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Additional Features to Explore\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The 0x Swap API is both powerful and user-friendly. Here are some features to explore:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://0x.org/docs/0x-swap-api/guides/monetize-your-app-using-swap\",\n          children: _jsx(_components.strong, {\n            children: \"Monetization\"\n          })\n        }), \": Generate revenue by integrating crypto swaps into your app.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://0x.org/docs/developer-resources/buy-sell-tax-support\",\n          children: _jsx(_components.strong, {\n            children: \"Buy/Sell Tax Support\"\n          })\n        }), \": Display transfer fees or buy/sell taxes in your UI effortlessly.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://0x.org/docs/introduction/api-issues\",\n          children: _jsx(_components.strong, {\n            children: \"Error Handling\"\n          })\n        }), \": Leverage the API’s robust error handling to ensure a smooth user experience, as 0x simulates every transaction.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Social Links\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you found this content helpful, please share it and tag \", _jsx(_components.a, {\n        href: \"https://x.com/0xProject\",\n        children: \"@0xproject\"\n      }), \" and the author \", _jsx(_components.a, {\n        href: \"https://x.com/hey_its_jlin\",\n        children: \"@hey_its_jlin\"\n      }), \" on X!\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",
      "frontmatter": {},
      "scope": {}
    }
  },
  {
    "id": "l1sload-guide-read-the-l1-state-from-l2",
    "name": "L1SLOAD guide: Read the L1 state from L2",
    "index": 8,
    "summary": "This precompile unlocks the Keystore and more, learn how to use it with examples.",
    "author": "FilosofiaCodigo",
    "authorIcon": "https://avatars.githubusercontent.com/u/707484?s=96&v=4",
    "authorLink": "https://x.com/FilosofiaCodigo",
    "published": "Sep 04, 2024",
    "readTime": "15 min read",
    "labels": [
      "Protocol"
    ],
    "content": {
      "compiledSource": "/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    em: \"em\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Seamless cross-chain account abstraction features will be possible thanks to the \", _jsx(_components.a, {\n        href: \"https://notes.ethereum.org/@vbuterin/minimal_keystore_rollup\",\n        children: \"Keystore\"\n      }), \". Where users will be able to control multiple smart contract accounts, on multiple chains, with a single key. This will bring rollups closer and provide the so long waited good UX for end users in a \", _jsx(_components.a, {\n        href: \"https://ethereum-magicians.org/t/a-rollup-centric-ethereum-roadmap/4698\",\n        children: \"rollup centric Ethereum\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In order to make this happen, we need to be able to read the L1 data from L2 rollups which is currently a very expensive process. That's why Scroll \", _jsx(_components.a, {\n        href: \"https://scroll.io/blog/towards-the-wallet-endgame-with-keystore\",\n        children: \"introduced\"\n      }), \" the \", _jsx(_components.code, {\n        children: \"L1SLOAD\"\n      }), \" precompile that is able to read the L1 State fast and cheap. Safe wallet is already creating \", _jsx(_components.a, {\n        href: \"https://github.com/5afe/safe-scroll-keystore\",\n        children: \"a proof of concept\"\n      }), \" \", _jsx(_components.a, {\n        href: \"https://www.youtube.com/watch?v=hHmOo7A3vNU\",\n        children: \"introduced at Safecon Berlin 2024\"\n      }), \" of this work and I think this is just the begining: DeFi, gaming, social and many more types of cross-chain applications are possible with this.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's now learn, with examples, the basics of this new primitive that is set to open the door to a new way of interacting with Ethereum.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. Connect your wallet to the devnet\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Currently, \", _jsx(_components.code, {\n        children: \"L1SLOAD\"\n      }), \" is available only on the Scroll Devnet. Please don't confuse it with the Scroll Sepolia Testnet. Although both are deployed on top of Sepolia Testnet, they are separate chains.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's start by connecting our wallet to Scroll Devnet:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Name: \", _jsx(_components.code, {\n          children: \"Scroll Devnet\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"RPC: \", _jsx(_components.code, {\n          children: \"https://l1sload-rpc.scroll.io\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Chain id: \", _jsx(_components.code, {\n          children: \"2227728\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Symbol: \", _jsx(_components.code, {\n          children: \"Sepolia ETH\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Explorer: \", _jsx(_components.code, {\n          children: \"https://l1sload-blockscout.scroll.io\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4myzwxva7wdp6j2vskcl.png\",\n        alt: \"staticcall example\",\n        width: \"750\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Connect to Scroll Devnet\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Get some funds on the L2 devnet\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are two methods for obtaining funds on the Scroll Devnet. Choose whichever option you prefer.\"\n    }), \"\\n\", _jsxs(\"details\", {\n      children: [_jsx(\"summary\", {\n        children: \"Telegram faucet bot (recommended)\"\n      }), _jsxs(_components.p, {\n        children: [\"Join \", _jsx(_components.a, {\n          href: \"https://t.me/scroll_l1sload_devnet_bot\",\n          children: \"this telegram group\"\n        }), \" and type \", _jsx(_components.code, {\n          children: \"/drop YOURADDRESS\"\n        }), \" (e.g. \", _jsx(_components.code, {\n          children: \"/drop 0xd8da6bf26964af9d7eed9e03e53415d37aa96045\"\n        }), \") to receive funds directly to your account.\"]\n      })]\n    }), \"\\n\", _jsxs(\"details\", {\n      children: [_jsx(\"summary\", {\n        children: \"Sepolia Bridge\"\n      }), _jsx(_components.p, {\n        children: \"You can bridge Sepolia ETH from Sepolia Testnet to Sepolia Devnet through the Scroll Messenger. There are different ways of achieving this but in this case we're going to use Remix.\"\n      }), _jsxs(_components.p, {\n        children: [\"Let's start by connecting your wallet with Sepolia ETH to Sepolia Testnet. Remember you can get some Sepolia ETH for free \", _jsx(_components.a, {\n          href: \"https://sepoliafaucet.com/\",\n          children: \"from a faucet\"\n        }), \".\"]\n      }), _jsx(_components.p, {\n        children: \"Now compile the following interface.\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-solidity\",\n          children: \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface ScrollMessanger {\\nfunction sendMessage(address to, uint value, bytes memory message, uint gasLimit) external payable;\\n}\\n\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Next, on the Deploy & Run tab connect the following contract address: \", _jsx(_components.code, {\n          children: \"0x9810147b43D7Fa7B9a480c8867906391744071b3\"\n        }), \".\"]\n      }), _jsxs(\"div\", {\n        className: \"text-center\",\n        children: [_jsx(\"img\", {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/opjs8r2ojy7epjmijjbw.png\",\n          alt: \"staticcall example\",\n          width: \"500\"\n        }), _jsx(_components.p, {\n          children: _jsx(_components.em, {\n            children: \"Connect Scroll Messenger Interface on Remix\"\n          })\n        })]\n      }), _jsxs(_components.p, {\n        children: [\"You can now send ETH by calling the \", _jsx(_components.code, {\n          children: \"sendMessage\"\n        }), \" function. As explained below:\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"to: Your EOA wallet address. The the ETH recipient on L2\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"value: The amount you wish to receive on L2 in wei. For example, if you want to send \", _jsx(_components.code, {\n            children: \"0.01\"\n          }), \" ETH you should pass \", _jsx(_components.code, {\n            children: \"10000000000000000\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"message: Leave this empty, just pass \", _jsx(_components.code, {\n            children: \"0x00\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"gasLimit: \", _jsx(_components.code, {\n            children: \"1000000\"\n          }), \" should be fine\"]\n        }), \"\\n\"]\n      }), _jsxs(_components.p, {\n        children: [\"Also remember to pass some value to your transaction. And add some extra ETH to pay for fees on L2, \", _jsx(_components.code, {\n          children: \"0.001\"\n        }), \" should be more than enough. So if for example you sent \", _jsx(_components.code, {\n          children: \"0.01\"\n        }), \" ETH on the bridge, send a transaction with \", _jsx(_components.code, {\n          children: \"0.011\"\n        }), \" ETH to cover the fees.\"]\n      }), _jsxs(\"div\", {\n        className: \"text-center\",\n        children: [_jsx(\"img\", {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/zwkdvhyt23j4k9i2x8e4.png\",\n          alt: \"staticcall example\",\n          width: \"500\"\n        }), _jsx(_components.p, {\n          children: _jsx(_components.em, {\n            children: \"Send ETH from Sepolia to Scroll Devnet\"\n          })\n        })]\n      }), _jsx(_components.p, {\n        children: \"Click the transact button and your funds should be available in around 15 mins.\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Deploy a contract on L1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As mentioned earlier, \", _jsx(_components.code, {\n        children: \"L1SLOAD\"\n      }), \" reads L1 contract state from L2. Let's deploy a simple L1 contract with a \", _jsx(_components.code, {\n        children: \"number\"\n      }), \" variable and later access it from L2.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.20;\\n\\n// Dummy contract we'll deploy on L1 and then read the state from L2\\ncontract L1Storage {\\n\\n    // This is the first variable declared on this contract so it will be stored at the slot 0\\n    uint256 public number;\\n\\n    // Stores a variable\\n    function store(uint256 num) public {\\n        number = num;\\n    }\\n\\n    // Returns the number stored, keep in mind we won't call this function from L2 since we'll read the slot directly\\n    function retrieve() public view returns (uint256){\\n        return number;\\n    }\\n\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now call the \", _jsx(_components.code, {\n        children: \"store(uint256 num)\"\n      }), \" function and pass a new value. For example let's pass \", _jsx(_components.code, {\n        children: \"42\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/0oecx64a2vthd8mjsx5l.png\",\n        alt: \"staticcall example\",\n        width: \"500\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"Store a value on L1\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. Retrieve a Slot from L2\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now let's deploy the following contract on L2 by passing the L1 contract address we just deployed as constructor param.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.20;\\n\\ninterface IL1Blocks {\\nfunction latestBlockNumber() external view returns (uint256);\\n}\\n\\ncontract L2Storage {\\n// This precompile returns the latest block accesible by L2, it is not mandatory to use this precompile but it can help to keep track of the L2 progress\\naddress constant L1_BLOCKS_ADDRESS = 0x5300000000000000000000000000000000000001;\\n// This is the L1SLOAD precompile address\\naddress constant L1_SLOAD_ADDRESS = 0x0000000000000000000000000000000000000101;\\n// The number varaiable is stored at the slot 0\\nuint256 constant NUMBER_SLOT = 0;\\naddress immutable l1StorageAddr;\\n\\n    // The constructor receives the contract we just deployed on L1\\n    constructor(address _l1Storage) {\\n        l1StorageAddr = _l1Storage;\\n    }\\n\\n    // Again, this function is for reference only. It returns the latest L1 block number red by L2\\n    function latestL1BlockNumber() public view returns (uint256) {\\n        uint256 l1BlockNum = IL1Blocks(L1_BLOCKS_ADDRESS).latestBlockNumber();\\n        return l1BlockNum;\\n    }\\n\\n    // Returns the number read from L1\\n    function retrieveFromL1() public view returns(uint) {\\n        // The precompile expects the contract address number and an array of slots. In this case we only query one, the slot 0\\n        bytes memory input = abi.encodePacked(l1StorageAddr, NUMBER_SLOT);\\n        bool success;\\n        bytes memory ret;\\n        // We can access any piece of state of L1 through a staticcall, this makes it simple and cheap\\n        (success, ret) = L1_SLOAD_ADDRESS.staticcall(input);\\n        if (!success) {\\n            revert(\\\"L1SLOAD failed\\\");\\n        }\\n        return abi.decode(ret, (uint256));\\n    }\\n\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Notice this contract first calls \", _jsx(_components.code, {\n        children: \"latestL1BlockNumber()\"\n      }), \" to get the latest L1 block that L2 has visibility on. And then calls \", _jsx(_components.code, {\n        children: \"L1SLOAD\"\n      }), \" (opcode \", _jsx(_components.code, {\n        children: \"0x101\"\n      }), \") by passing the L1 contract address and the slot 0 where the \", _jsx(_components.code, {\n        children: \"uint number\"\n      }), \" is stored.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now we can call \", _jsx(_components.code, {\n        children: \"retrieveFromL1()\"\n      }), \" to get the value we previously stored.\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      className: \"text-center\",\n      children: [_jsx(\"img\", {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/p92y2kkjb9ecvtcv32re.png\",\n        alt: \"staticcall example\",\n        width: \"500\"\n      }), _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"L2SLOAD L1 State red from L2\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Example #2: Reading other variable types\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Luckily for us, Solidity stores the slots in the same order as they were declared. For example, in the following contract \", _jsx(_components.code, {\n        children: \"account\"\n      }), \" will be stored on slot #0, \", _jsx(_components.code, {\n        children: \"number\"\n      }), \" slot #1 and \", _jsx(_components.code, {\n        children: \"text\"\n      }), \" on slot #2.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0 <0.9.0;\\n\\n// This time we will query multiple slots with diverse data types\\ncontract AdvancedL1Storage {\\naddress public account = msg.sender;\\nuint public number = 42;\\nstring public str = \\\"Hello world!\\\";\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, you can notice on the following example how you can query the different slots and decode accordingly to uint256, address, etc... The only different native type that needs special decoding is the \", _jsx(_components.code, {\n        children: \"string\"\n      }), \" type.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.20;\\n\\n// This contract queries multiple slots in one call\\ncontract L2Storage {\\naddress constant L1_BLOCKS_ADDRESS = 0x5300000000000000000000000000000000000001;\\naddress constant L1_SLOAD_ADDRESS = 0x0000000000000000000000000000000000000101;\\naddress immutable l1ContractAddress;\\n\\n    constructor(address _l1ContractAddress) {\\n        l1ContractAddress = _l1ContractAddress;\\n    }\\n\\n    // String will need to be decoded to be returned as a typical solidity string\\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\\n        bytes memory bytesArray = new bytes(32);\\n        for (uint256 i; i < 32; i++) {\\n            if(_bytes32[i] == 0x00)\\n                break;\\n            bytesArray[i] = _bytes32[i];\\n        }\\n        return string(bytesArray);\\n    }\\n\\n    // In a single function, many slots can be retrieved\\n    function retrieveAll() public view returns(address, uint, string memory) {\\n        bool success;\\n        bytes memory data;\\n        // This time we will query slot 0 (account), slot 1 (number) and slot 2 (str)\\n        uint[] memory l1Slots = new uint[](3);\\n        l1Slots[0] = 0;\\n        l1Slots[1] = 1;\\n        l1Slots[2] = 2;\\n        (success, data) = L1_SLOAD_ADDRESS.staticcall(abi.encodePacked(l1ContractAddress, l1Slots));\\n        if(!success)\\n        {\\n            revert(\\\"L1SLOAD failed\\\");\\n        }\\n\\n        // We will store them in typical solidity variables\\n        address l1Account;\\n        uint l1Number;\\n        bytes32 l1Str;\\n\\n        // In order to read types with a size different than 32 bytes we will need a little bit of assembly\\n        // But fear not! The code is not as difficult as it sounds\\n        assembly {\\n            let temp := 0x20\\n            // Load the data into memory\\n            let ptr := add(data, 32) // Start at the beginning of data skipping the length field\\n\\n            // Store the first slot from L1 into the account variable\\n            mstore(temp, mload(ptr))\\n            l1Account := mload(temp)\\n            ptr := add(ptr, 32)\\n\\n            // Store the second slot from L1 into the number variable\\n            mstore(temp, mload(ptr))\\n            l1Number := mload(temp)\\n            ptr := add(ptr, 32)\\n\\n            // Store the third slot from L1 into the str variable\\n            mstore(temp, mload(ptr))\\n            l1Str := mload(temp)\\n        }\\n        return (l1Account, l1Number, bytes32ToString(l1Str));\\n    }\\n\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Example #3: Reading ERC20 token balance from L1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's start by deploying the following very simple ERC20 token.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n// In our final example, we'll read the balance of any ERC20 holder on L1\\n// Please note that we will be using OpenZeppelin's implementation which puts the balance mapping on slot 0, is is not enforced by the ERC20 standard\\ncontract SimpleToken is ERC20 {\\nconstructor() ERC20(\\\"Simple Token\\\", \\\"STKN\\\") {\\n\\\\_mint(msg.sender, 21_000_000 ether);\\n}\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, we can deploy the following contract on L2 by passing the L1 token address as parameter.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-solidity\",\n        children: \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.20;\\n\\ninterface IL1Blocks {\\nfunction latestBlockNumber() external view returns (uint256);\\n}\\n\\n// This contract reads the balance of any holder on L1\\ncontract L2Storage {\\naddress constant L1_BLOCKS_ADDRESS = 0x5300000000000000000000000000000000000001;\\naddress constant L1_SLOAD_ADDRESS = 0x0000000000000000000000000000000000000101;\\naddress immutable l1TokenAddress;\\n\\n    constructor(address _l1TokenAddress) {\\n        l1TokenAddress = _l1TokenAddress;\\n    }\\n\\n    // Retrieves the token balance of a given Ethereum account.\\n    function retrieveL1Balance(address account) public view returns(uint) {\\n        // We assume that the balance mapping is stored at slot number 0\\n        uint slotNumber = 0;\\n        // The formula that Solidity uses to compute the slot in mappings is: balanceSlotPosition = keccak256(holderAddress, slotNumber)\\n        uint accountBalanceSlot = uint(\\n            keccak256(abi.encodePacked(uint(uint160(account)),\\n            slotNumber)\\n        ));\\n        // Now, we perform a staticcall to the l1sload precompile to retrieve the account balance\\n        bool success;\\n        bytes memory returnValue;\\n        (success, returnValue) = L1_SLOAD_ADDRESS.staticcall(abi.encodePacked(l1TokenAddress, accountBalanceSlot));\\n        if(!success)\\n        {\\n            revert(\\\"L1SLOAD failed\\\");\\n        }\\n        // The retrieved value is in bytes32 format, so we cast it to uint256 before returning it\\n        return abi.decode(returnValue, (uint));\\n    }\\n\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"OpenZeppelin contracts conveniently places \", _jsx(_components.a, {\n        href: \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L30\",\n        children: \"the balances mapping on Slot 0\"\n      }), \". So you can call \", _jsx(_components.code, {\n        children: \"retrieveL1Balance()\"\n      }), \" by passing the account address as parameter and the token balance will be returned. As you can see on the code, it works by converting the account to \", _jsx(_components.code, {\n        children: \"uint160\"\n      }), \" and then hashing it with the mapping slot which is 0. This is because that's the way the Solidity implemented mappings.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Next steps\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"l1sload\"\n      }), \" precompile is currently under public scrutiny before its testnet deployment. Consider sharing your thoughts on the \", _jsx(_components.a, {\n        href: \"https://ethereum-magicians.org/t/rip-7728-l1sload-precompile/20388\",\n        children: \"Ethereum Magicians Forum\"\n      }), \" to help shape its development through community feedback.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",
      "frontmatter": {},
      "scope": {}
    }
  }
]